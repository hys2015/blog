<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>持之以恒</title>
  <subtitle>Blogs make you know where your soul has been</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://hengyishu.cn/"/>
  <updated>2018-08-04T03:02:21.714Z</updated>
  <id>http://hengyishu.cn/</id>
  
  <author>
    <name>Mark Heng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>作业部落博客目录</title>
    <link href="http://hengyishu.cn/2018/08/04/%E4%BD%9C%E4%B8%9A%E9%83%A8%E8%90%BD%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/"/>
    <id>http://hengyishu.cn/2018/08/04/作业部落博客目录/</id>
    <published>2018-08-04T03:02:17.000Z</published>
    <updated>2018-08-04T03:02:21.714Z</updated>
    
    <content type="html"><![CDATA[<p>blog写md不能直接预览，自己也犯懒，就写到了在线编辑器里，这里留个目录。<br><a id="more"></a></p>
<ul>
<li><a href="https://zybuluo.com/markheng/note/1237983" target="_blank" rel="external">STL源码剖析笔记 - traits编程技法</a></li>
<li><a href="https://zybuluo.com/markheng/note/1236510" target="_blank" rel="external">STL源码剖析笔记 - STL的Allocator</a></li>
<li><a href="https://zybuluo.com/markheng/note/1187219" target="_blank" rel="external">C++后台开发 2019秋招知识准备</a></li>
<li><a href="https://zybuluo.com/markheng/note/1074568" target="_blank" rel="external">设计模式 一览</a></li>
<li><a href="https://zybuluo.com/markheng/note/1201624" target="_blank" rel="external">iOS OpenGL对法向量进行插值</a></li>
<li><a href="https://zybuluo.com/markheng/note/1070646" target="_blank" rel="external">swift指针 - UnsafeWorld of Swift 3.0</a></li>
<li><a href="https://zybuluo.com/markheng/note/1070794" target="_blank" rel="external">Closure in Swift 3.0</a></li>
<li><a href="https://zybuluo.com/markheng/note/1109437" target="_blank" rel="external">BinarySearch - 二叉搜索</a></li>
<li><a href="https://zybuluo.com/markheng/note/1107236" target="_blank" rel="external">Binary Search Tree Iterator - LeetCode</a></li>
<li><a href="https://zybuluo.com/markheng/note/1107180" target="_blank" rel="external">验证二叉搜索树 Validate Binary Search Tree LeetCode</a></li>
<li><a href="https://zybuluo.com/markheng/note/665940" target="_blank" rel="external">Cholesky分解</a></li>
<li><a href="https://zybuluo.com/markheng/note/1128300" target="_blank" rel="external">人体重建论文两则 笔记</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;blog写md不能直接预览，自己也犯懒，就写到了在线编辑器里，这里留个目录。&lt;br&gt;
    
    </summary>
    
      <category term="日常" scheme="http://hengyishu.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="学习" scheme="http://hengyishu.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Skinning with Dual Quaternions - 对偶四元数蒙皮</title>
    <link href="http://hengyishu.cn/2017/05/16/Skinning-with-Dual-Quaternions-%E5%AF%B9%E5%81%B6%E5%9B%9B%E5%85%83%E6%95%B0%E8%92%99%E7%9A%AE/"/>
    <id>http://hengyishu.cn/2017/05/16/Skinning-with-Dual-Quaternions-对偶四元数蒙皮/</id>
    <published>2017-05-16T13:57:36.000Z</published>
    <updated>2017-05-17T10:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>蒙皮，就是根据控制单元的变化，控制相应的顶点的变化，线性蒙皮采用线性插值的方法计算变形前后的顶点的位置。</p>
<p>蒙皮的算法主要分为两步：</p>
<a id="more"></a>
<p>一，定义一系列的控制单元，计算几何模型受这些控制单元的影响权重；<br>二，控制单元改变，几何模型发生响应的形变。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>Linear Blending Skinning 线性蒙皮</strong></p>
<p>计算权重是一个很重要的步骤，有一种方法是有解双调和权重。定义控制单元为$H_j \in \Omega, j = 1, …, m$,每个控制单元$H_j$发生的仿射变换为$T_j$，对于顶点$p \in \Omega$，线性混合蒙皮算法给出变形后的$p’$的位置为控制单元仿射变换$T_j$的加权线性组合：<br>$$<br>\mathbf p’ = \sum_{j=1}^m w_j(\mathbf p)T_j\mathbf p<br>$$<br>$w_j(p)$为顶点$p$受控制单元$H_j$的权重影响。</p>
<p>有界双调和权重$w_j$的计算方法，参考<a href="http://delivery.acm.org/10.1145/2580000/2578850/414ChinaRH.pdf?ip=60.207.237.106&amp;id=2578850&amp;acc=ACTIVE%20SERVICE&amp;key=BF85BBA5741FDC6E%2E478E8F2EC4A762F8%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;CFID=763502609&amp;CFTOKEN=18159657&amp;__acm__=1494940210_1b518aa5c6721c094dd286d0a7feeef7" target="_blank" rel="external">论文</a>第3节“有界双调和权重”。</p>
<p>对权重的$w_j$定义为高阶形状感知平滑度泛函（即拉普拉斯能量）的极小化变量，并服从控制点插值和多个其它理想属性的约束：<br>$$<br>argmin_{\substack{w_j, \ j = 1,\dots,m}}\sum^m_{j=1}\frac{1}{2}\int_{\Omega}(\Delta w_j)^2 dV<br>$$<br>服从：<br>$$<br>\begin{align}<br>&amp;w_j | _{Hk} = \delta_{jk}, &amp; \tag{1} \\<br>&amp;w_j | _F为线性, &amp; \forall F \in \mathcal F_c  \tag{2} \\<br>&amp;\sum_{j=1}^m w_j(p) = 1 &amp; \forall p \in \Omega \tag{3} \\<br>&amp;0 \le w_j(p) \le 1, j = 1, \dots, m, &amp; \forall p \in \Omega \tag{4}<br>\end{align}<br>$$<br>其中，$\mathcal F_c$是所有控制面的合集，$\delta_{jk}$是<a href="http://baike.baidu.com/item/Kronecker%20delta" target="_blank" rel="external">克罗内克函数</a>。<br><strong>LBS的塌陷问题</strong><br>LBS插值，在控制点旋转导致原本的顶点连接线相交时，插值会导致蒙皮塌陷问题。<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/5-16/lbs.gif" alt="LBS" title="LBS塌陷"></p>
<p><strong>DQB</strong><br><a href="https://www.cs.utah.edu/~ladislav/kavan07skinning/kavan07skinning.pdf" target="_blank" rel="external"><strong>Dual Quaternions Linearing Skinning</strong></a><br>DQB可以解决上述问题。<br>DQB中使用的是<strong>对偶四元数</strong>。<br><strong>常规四元数</strong>的理解见下面链接：<br><a href="https://www.zhihu.com/question/23005815" target="_blank" rel="external">四元数</a><br><a href="http://www.qiujiawei.com/understanding-quaternions/" target="_blank" rel="external">Understanding quaternions</a><br><img src="http://7xrsid.com1.z0.glb.clouddn.com/5-16/qdb.gif" alt="DQB" title="DQB"></p>
<p>常规四元数只能表示空间的旋转变换，数学形式为$q = [cos(\theta / 2), n_x sin(\theta/2), n_y sin(\theta/2) , n_z sin(\theta/2)]$，其中$(n_x, n_y, n_z)$表示通过原点的旋转轴，$\theta$为旋转角度。</p>
<p>对偶数类似于复数，定义为 $\hat z = a_0 + \varepsilon a_{\varepsilon}, a_0 \in \Bbb R, a_{\varepsilon} \in \Bbb R$，满足$\varepsilon ^2 = 0$，称$a_0$为实部，$a_\varepsilon$为对偶部，$\varepsilon$为对偶算子，类似于复数中的$i$。<strong>对偶四元数</strong>是实部和对偶部都为四元数的对偶数，又可称为八元数。常规四元数只能表示空间旋转，而对偶四元数可以表示空间任意旋转和平移的组合。</p>
<p>对偶四元数定义为：<br>$$<br>\hat{\mathbf q} = \hat w + i\hat x + j \hat y + k \hat z<br>$$<br>其中，$w$是标量部分（对偶数），$(\hat x, \hat y, \hat z)$是向量部分，$i,j,k$是普通四元数算子。对偶算子$\varepsilon$和四元数算子是可交换的(commute)，比如$\varepsilon i = i \varepsilon$.<br>所以对偶四元数可以写成两个普通四元数的和的形式：<br>$$<br>\hat{\mathbf q} = \mathbf q_0 + \varepsilon \mathbf q_\varepsilon<br>$$<br>其中，$\mathbf q_0, \mathbf  q_\varepsilon$均为普通四元数。</p>
<p><strong>共轭</strong><br>对偶四元数的共轭：<br>$$<br>\hat{\mathbf q}^\star = \mathbf q_0^\star + \varepsilon \mathbf q_\varepsilon ^\star<br>$$</p>
<p><strong>单位对偶四元数</strong><br>$\hat{\mathbf q}$是单位化的，当且仅当$||\mathbf q_0|| = 1, \langle \mathbf q_0, \mathbf q_\varepsilon \rangle = 0$, $||\cdot||$表示模长，$\langle \cdot, \cdot \rangle$表示内积。</p>
<p><strong>对偶四元数表示3D旋转变换</strong></p>
<p>当对偶四元数的对偶部$\mathbf q_\varepsilon = \mathbf 0$时，该对偶四元数即表示3D旋转。</p>
<p>对偶四元数可写为<br>$$<br>\hat{\mathbf q_r }= [cos(\theta/2), n_xcos(\theta/2), n_ycos(\theta/2), n_zcos(\theta/2)][0 \ 0 \ 0 \ 0]<br>$$<br>其中，对偶部为$\mathbf 0$.</p>
<p>给定向量$\hat v = (v_0, v_1, v_2)$，$q$表示旋转的对偶四元数，那么向量$v$的旋转结果可以写为：<br>$$<br>\hat q \hat v \overline{\hat q ^\star}<br>$$<br>$\overline{\hat q ^\star}$ 表示共轭对偶四元数。</p>
<p><strong>对偶四元数表示3D平移变换</strong><br>定义一个单位对偶四元数$\hat {\mathbf t} = 1 + \frac{\varepsilon}{2} (t_0 i + t_1 j + t_2 k)$对应为向量$(t_0, t_1, t_2)$表示的平移变换（取变换向量的一半，跟普通四元数表示旋转变换取角度的一半类似）</p>
<p>写成对偶四元数形式：<br>$$<br>\hat{\mathbf q_t} = [1 \ 0 \ 0 \ 0 ][0 \ \frac{t_x}{2} \ \frac{t_y}{2} \ \frac{t_z}{2}]<br>$$</p>
<p><strong>旋转和平移结合起来</strong><br>将上述两种情况结合起来，仍然用$\mathbf q_0$表示旋转对偶四元数，平移变换仍然表示为$1 + \frac{\varepsilon}{2} (t_0 i + t_1 j + t_2 k)$，那么结合起来就得到:<br>$$<br>\hat{\mathbf q_t} \hat{\mathbf q_r} = (1 + \frac{\varepsilon}{2} (t_0 i + t_1 j + t_2 k))\mathbf q_0 = \mathbf q_0 + \frac{\varepsilon}{2} (t_0 i + t_1 j + t_2 k)\mathbf q_0<br>$$</p>
<h2 id="Dual-quaternion-Linear-Blending"><a href="#Dual-quaternion-Linear-Blending" class="headerlink" title="Dual-quaternion Linear Blending"></a>Dual-quaternion Linear Blending</h2><p>首先将蒙皮的顶点变换转换称为对偶四元数$\hat{\mathbf q_1},\dots, \hat{\mathbf q_n}$。然后按照权重，计算每个变换对顶点的影响，通过线性组合的方式，写为：<br>$$<br>DLB(\mathbf w; \hat{\mathbf q_1, \dots, \hat{\mathbf q_n}}) = \frac{w_1 \hat{\mathbf q_1} + \dots + w_n \hat{\mathbf q_n}}{||w_1 \hat{\mathbf q_1} + \dots + w_n \hat{\mathbf q_n} ||}<br>$$</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><strong>输入</strong>： </p>
<ul>
<li>对偶四元数$\hat{\mathbf q_1}, \dots, \hat{\mathbf q_n}$(全局变量)</li>
<li>顶点位置$v$ 和 法向量$v_n$</li>
<li>关节索引 $j_1, \dots, j_n$ 和权重$w_1, \dots, w_n$</li>
</ul>
<p><strong>输出</strong>：变换后的顶点坐标$v’$和法向量$v_n’$</p>
<p>$\hat{ \mathbf b }= w_1 \hat{\mathbf q_1} + \dots + w_n \hat{\mathbf q_n}$<br>//记$\hat{\mathbf b}$中的实部为$\mathbf b_0$，对偶部为$\mathbf b_\varepsilon$<br>$\mathbf c_0 = \mathbf b_0 / ||\mathbf b_0||$<br>$\mathbf c_\varepsilon = \mathbf b_\epsilon / ||\mathbf b_0||$<br>//记$\mathbf c_0$为 $w_0, x_0, y_0, z_0$<br>//记$\mathbf c_\varepsilon$为 $w_\varepsilon, x_\varepsilon, y_\varepsilon, z_\varepsilon$<br>$t_0 = 2(-w_\varepsilon x_0 + x_\varepsilon w_0 - y_\varepsilon z_0 + z_\varepsilon y_0)$<br>$t_1 = 2(-w_\varepsilon x_0 + x_\varepsilon z_0 + y_\varepsilon w_0 - z_\varepsilon x_0)$<br>$t_2 = 2(-w_\varepsilon z_0 - x_\varepsilon y_0 + y_\varepsilon x_0 + z_\varepsilon w_0)$<br>$$<br>M =<br>\begin{pmatrix}<br>1 - 2y_0^2 - 2z_0^2 &amp; 2x_0y_0 - 2w_0z_0 &amp; 2x_0z_0 + 2w_0y_0 &amp; t_0 \\<br>2x_0y_0 + 2w_0z_0 &amp; 1 - 2x_0^2 - 2z_0^2 &amp; 2y_0z_0 - 2w_0x_0 &amp; t_1 \\<br>2x_0z_0 - 2w_0y_0 &amp; 2y_0z_0 + 2w_0x_0 &amp; 1 - 2x_0^2 - 2y_0^2 &amp; t_2<br>\end{pmatrix}<br>$$<br>$v’ = M v$     // $v$的结构为$(v_0, v_1, v_2, 1)$<br>$v_n’ = M v_n$ // $v_n$的结构为$(v_{n, 0}, v_{n, 1}, v_{n,2}, 0)$</p>
</blockquote>
<p>有些细节没有说明，可以参考<a href="https://www.cs.utah.edu/~ladislav/kavan07skinning/kavan07skinning.pdf" target="_blank" rel="external">论文</a>。</p>
<p>参考：<br><a href="https://www.zhihu.com/question/32007883" target="_blank" rel="external">https://www.zhihu.com/question/32007883</a><br><a href="http://www.cnblogs.com/shushen/p/5987280.html" target="_blank" rel="external">http://www.cnblogs.com/shushen/p/5987280.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒙皮，就是根据控制单元的变化，控制相应的顶点的变化，线性蒙皮采用线性插值的方法计算变形前后的顶点的位置。&lt;/p&gt;
&lt;p&gt;蒙皮的算法主要分为两步：&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="算法" scheme="http://hengyishu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="fusion" scheme="http://hengyishu.cn/tags/fusion/"/>
    
      <category term="rgbd" scheme="http://hengyishu.cn/tags/rgbd/"/>
    
      <category term="四元数" scheme="http://hengyishu.cn/tags/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    
      <category term="对偶四元数" scheme="http://hengyishu.cn/tags/%E5%AF%B9%E5%81%B6%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>DynamicFusion - 论文阅读</title>
    <link href="http://hengyishu.cn/2017/05/16/DynamicFusion-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://hengyishu.cn/2017/05/16/DynamicFusion-论文阅读/</id>
    <published>2017-05-16T08:16:33.000Z</published>
    <updated>2017-05-16T14:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>newcombe大神2015的论文，叼的不行。。。<br><a href="https://rse-lab.cs.washington.edu/papers/dynamic-fusion-cvpr-2015.pdf" target="_blank" rel="external">论文地址</a><br><a id="more"></a></p>
<h2 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h2><p>DF将非刚性形变场景分解到隐性几何表面，重建到刚性规范空间中。还有每帧的形变场，将上述表面转换到当前帧中。<br>每新的一幅深度帧，以下三种算法依次执行：</p>
<ol>
<li>建立体元的“模型到帧”变形场参数</li>
<li>将当前深度帧通过变形场映射进规范空间</li>
<li>调整变形场的结构以匹配新加入的几何体</li>
</ol>
<h2 id="3-Technical-Details"><a href="#3-Technical-Details" class="headerlink" title="3. Technical Details"></a>3. Technical Details</h2><p>DNWF方便对场景中的每帧形变进行建模。变形场是所有其他功能的基础。</p>
<h3 id="3-1-Dense-Non-rigid-Warp-Field"><a href="#3-1-Dense-Non-rigid-Warp-Field" class="headerlink" title="3.1 Dense Non-rigid Warp Field"></a>3.1 Dense Non-rigid Warp Field</h3><p>变形场，提供一个针对每个点的6自由度变换$\mathcal{W}: S \rightarrow SE(3)$<br>对规范mesh中的每个点$v_c \in S$, 变换$T_{lc} = \mathcal W (v_c)$把规范空间中的点转换到当前空间。</p>
<p>每一帧深度图像，都需要建立变形公式，$\mathcal W_t$，它的表示必须要有效的优化。一种方法是对体素进行密集的取样，但是这样运算量太大，不适用。<br><strong>实际上，用一个变换的稀疏集合作为基，用插值的方法就可以定义稠密的体素变形方程。</strong></p>
<p>使用如下方式，定义变形函数：<br><strong>DQB(<a href="https://www.cs.utah.edu/~ladislav/kavan06dual/kavan06dual.pdf" target="_blank" rel="external">paper</a>,<a href="http://hengyishu.cn/blog/2017/05/16/Skinning-with-Dual-Quaternions-对偶四元数蒙皮/#more">我的博文</a>): dual-quaternion blending双四元数混合</strong><br>$$<br>\mathcal W_t(x_c) = SE3(\mathbf{DQB}(x_c)).<br>$$<br>其中<br>$$<br>\mathbf{DQB}(x_c) = \frac{\sum_{k \in N(x_c)}\mathbf w_k(x_c) \mathbf {\hat q_{kc}}}{||\sum_{k \in N(x_c)} \mathbf w_k(x_c) \hat q_{kc}||}<br>$$<br>每个单位的双四元数$\mathbf{\hat q_{kc} \in \Bbb R ^8}$。<br>$N(x)$是点$x$的$k$最近邻的变换结点，$\mathbf w_k$定义了权重来调整每个结点的影响半径。<br>$\mathbf{SE3}(·)$将四元数转变回$\mathbf{SE(3)}$变换矩阵。</p>
<p>$t$时刻的变形场的状态为$\mathcal W_t$，定义为$n$个变换结点集合的值$\mathcal N^t_{\mathbf{warp}} = \{dg_v, dg_w, dg_{se3}\}_t$。对结点$i = 1 \dots n$，都在标准空间中有个位置$dg_v^i \in \Bbb R^3 $，相关的变换$T_{ic} = dg^i_{se3}$，径向基权重$dg_w$控制变换的程度 $w_i(x_c) = \mathrm{exp}(-||\mathbf{dg}_v^i - x_c||^2 / (2(\mathbf{dg}_w^i)^2))$.</p>
<p>每个半径参数$dg^i_w$设定为保证结点的影响能够覆盖到相邻的若干结点，取决于结点取样的系数程度，$ \S 3.4 $详细介绍。</p>
<p>变形场对所有支持的空间都有效，所以可以对位置和朝向（方向向量）都有效。而且，空间的尺度变化也能够通过相邻点的收敛和发散来表示空间的收缩和扩大。最后，可以用因子表示对体素中所有的点都有效的变换。引入将模型变换至当前帧的变换，$T_{lw}$，并写入体素变形函数，得到:<br>$$<br>\mathcal W_t(x_c) = T_{lw} SE3(\mathbf{DQB}(x_c)).<br>$$</p>
<h3 id="3-2-Dense-Non-rigid-Surface-Fusion"><a href="#3-2-Dense-Non-rigid-Surface-Fusion" class="headerlink" title="3.2 Dense Non-rigid Surface Fusion"></a>3.2 Dense Non-rigid Surface Fusion</h3><p>此节介绍根据变形场$\mathcal W_t$，更新标准模型几何形状。标准空间(canonical space)$S$，通过取样的$TSDF \ \  \mathcal V : \mathsf S \mapsto \Bbb R^2$，体素域$\mathsf S \subset \Bbb N^3$。取样函数保有每个对应取样点$x_c$的体元$x\in \mathsf S$，二元组$\mathcal V(x) \mapsto [v(x) \in \Bbb R, w(x) \in \Bbb R ]^\top$保有了点$v(x)$所有投影$TSDF$目前的加权平均值，$w(x)$为相关的权重之和。</p>
<p>本文使用跟KinectFusion的方法操作非刚体变形场景。给定深度图$D_t$，通过建立的变换，将体素中心$x_c \in S$变换到当前帧$(x^\top_t, 1)^\top = \mathcal W(x_c)(x_c^\top, 1)^\top$，通过把变换后的中心投影到深度图来维持TSDF表面融合操作。这就可以让TSDF中的体素通过在变形帧计算投影TSDF更新，而不用必须在当前帧中的变形TSDF进行再采样。变形过的标准点（canonical point）投影的符号距离(signed distance)是:<br>$$<br>psdf(x_c)  =[K^{-1} D_t(u_c) [u_c^\top, 1 ]^\top]_z -[x_t]_z<br>$$<br>$u_c = \pi(Kx_t)$是体素中心投影的像素点。$[·]_z$表示在帧空间的光$(z)$轴上的距离。K是内参，$\pi$是投影变换。对每个体素$x$, 用TSDF融合，更新TSDF，以便于它包含到变形帧投影的SDF：<br>$$<br>\mathcal V(x)_t =<br>\begin{cases}<br>[v’(x), w’(x)]^\top, &amp;if \ \ \  psdf(dc(x)) &gt; -\tau \\<br>\mathcal V(x)_{t-1}, &amp;otherwise<br>\end{cases}<br>$$<br>$dc(.)$将离散体素点转换到连续的TSDF域中。<br>$\tau &gt; 0$是截断距离，根据加权平均策略，更新TSDF，加权截断方式：<br>$$<br>\begin{align}<br>v’(x) &amp;= \frac{v(x)_{t-1}w(x)_{t-1} + min(\rho, \tau)w(x)}{w(x)_{t-1} + w(x)} \tag{1} \\<br>\rho &amp;= psdf(dc(x)) \tag{2} \\<br>w’(x) &amp;= min(w(x)_{t-1} + w(x), w_{max}) \tag{3}<br>\end{align}<br>$$<br>权重$w(x)$表示在深度帧投影点观察的深度的不确定性，也表示与$x_c$处变形函数的关联程度的不确定性。非刚性变形的情况下，点$x_c$离已经映射好和观察到的区域，就越不确定它的变换。</p>
<p><strong>使用$x_c$到它k最近临的形变结点的平均距离作为上述不确定性和尺度的代理：</strong>$w(x) \propto \frac{1}{k} \sum_{i \in N(x_c)} ||dg_w^i - x_c||_2$. 用每个体素的变换将相关的体素变换到当前非刚性帧。</p>
<h3 id="3-3-Estimating-the-Warp-field-State"><a href="#3-3-Estimating-the-Warp-field-State" class="headerlink" title="3.3 Estimating the Warp-field State"></a>3.3 Estimating the Warp-field State</h3><p>文章基于当前深度图$D_t$和当前重建$\mathcal V$，通过可以被参数最小化的能量函数，构建变形场$\mathcal W_t$中的变换$dg_{se3}$，能量函数为:<br>$$<br>E(\mathcal W_t, \mathcal V, D_t) = Data(\mathcal W_t, \mathcal V, D_t) + \lambda Reg(\mathcal W_t, \mathcal E)<br>$$<br>$Data(\mathcal W_t, \mathcal V, D_t)$为模型到帧ICP的花费，规格化项$Reg(\mathcal W_t, \mathcal E)$防止不平滑的移动场，并且保证被<strong>边集合</strong>$\mathcal E$连接的点进行ARAP变换。$\lambda$是平衡系数。</p>
<h4 id="3-3-1-Dense-Non-Rigid-ICP-Data-term"><a href="#3-3-1-Dense-Non-Rigid-ICP-Data-term" class="headerlink" title="3.3.1 Dense Non-Rigid ICP Data-term"></a>3.3.1 Dense Non-Rigid ICP Data-term</h4><p>为了构建所有的变换矩阵$T_{ic}$和$T_{lw}$，文章将标准体元中零面（zero level set)提取出来，变换到当前帧中。</p>
<p><strong>surface prediction and data-association</strong><br>TSDF$\mathcal V$中的零面，通过marching cubes方法提取出来，并且以顶点-法向对的方式存储到标准空间：$\hat{ \mathcal V} = {V_c, N_c}$，通过变形场$W_t$将$\hat{\mathcal V_c}$变换到$\hat{\mathcal V_w}$.</p>
<p>通过将变换后的平面$V_w$投影到当前帧，渲染出标准空间中的点，来得到（最终）模型的几何和当前帧的数据关联（对应）。<br>结果可以得到标准模型中在当前帧可见的几何面的预测:$\mathcal P(\hat{\mathcal V_c})$.将这个预测保存为图像对$\{v, n\} : \Omega \mapsto \mathcal P(\hat{\mathcal V_c})$,$\Omega$是预测的图像，保存了渲染的标准空间的顶点和法向。</p>
<p>给出当前时间帧优化过的变换参数，预测可见的平面应该会向当前阵的表面变换的更近，噪音更少。当前表面$\mathbf{vl}: \Omega \mapsto \Bbb R^3$，由深度图反投影表示$[\mathbf{vl}(u)^\top, 1]^\top = K^{-1}D_t(u)[u^\top, 1]^\top$.</p>
<p>每像素的稠密模型到帧的点到面误差可以量化上述变化，文章通过Tukey惩罚函数$\psi_{data}$，整合了整个图片域$\Omega$:<br>$$<br>Data(\mathcal W, \mathcal V, D_t) = \sum_{u\in \Omega} \psi_{data}(\hat n_u^\top(\hat v_u - vl_{\tilde u}))<br>$$</p>
<p>将模型顶点$v(u)$变换到当前帧的预测位置: $\tilde T^u = \mathcal W(v(u))$，得到响应的顶点-法向预测值： $\hat v_u = \tilde T^u v(u), \hat n_u = \tilde T^u n(u)$，模型的顶点-法向数据和当前帧顶点-法向数据关联可以通过透视投影像素：$\tilde u = \pi (K \hat v_u)$</p>
<p>每个数据项的加数仅依赖计算变形场$\mathcal W$的n的变换的子集。</p>
<h4 id="3-3-2-Warp-field-Regularization"><a href="#3-3-2-Warp-field-Regularization" class="headerlink" title="3.3.2 Warp-field Regularization"></a>3.3.2 Warp-field Regularization</h4><p>非刚体TSDF融合不仅需要估算可见面的变形，要估计整个正规空间$\mathsf S$。这样才能够对即将进入场景的面进行建模。但是当前不可见的面不会有关联数据项。文章认为不可见面的运动是分段平滑的。</p>
<p>规则化项<br>$$<br>Reg(\mathcal W, \mathcal E) = \sum^n_{i=0} \sum_{j\in \mathcal E(i)} \alpha_{ij} \psi_{reg} (T_{ic}dg_v^j - T_{jc} dg^j_v)<br>$$<br>$\mathcal E$定义了规格化图拓扑，$\alpha_{ij}$定义了边关联的权重，设定为$\alpha_{ij} = max(dg^i_w, dg^j_w)$</p>
<p><strong>Hierarchical Deformation Tree</strong><br>构建层次变形树可以提高变形场的稳定性和减小能量函数优化的开销。</p>
<p>给定当前形变结点集合$\mathcal N_{warp}$，构建一个规格化结点的层次结构$\mathcal N_{reg} = \{r_v, r_{se3}, r_w\}$，3.4节介绍如何构建。</p>
<p>文章不使用变形函数$\mathcal W$中的$\mathcal N_{reg}$，它被用来引入跨越变形函数的长范围（long range）的规格化，这些变形函数已经经过优化，降低了计算复杂度。</p>
<p>规格化图拓扑可以简单的通过把层中（从$\mathcal N_{warp}$开始）的每个点与它下一层的k临近点添加边来构建。</p>
<p>整个融合过程中需要以帧率的速度更新变形结点和规格化图。</p>
<h4 id="3-3-3-Efficient-Optimization"><a href="#3-3-3-Efficient-Optimization" class="headerlink" title="3.3.3 Efficient Optimization"></a>3.3.3 Efficient Optimization</h4><p>将总能量$E$最小化，可以估计出所有的变换参数$T_{lw}, dg_{se3}, r_{se3}$.<br>用<a href="http://www.voidcn.com/blog/jinshengtao/article/p-6004352.html" target="_blank" rel="external">高斯牛顿法</a>求解最小化</p>
<p>最小化能量公式中的复杂度集中在近似化海因公式：$J^\top J = J^\top_d J_d + \lambda J_r^\top J_r$.</p>
<h3 id="3-4-Extending-the-Warp-field"><a href="#3-4-Extending-the-Warp-field" class="headerlink" title="3.4 Extending the Warp-field"></a>3.4 Extending the Warp-field</h3><p>这里扩展了变形场的参数，确保所有的变形都被表示出来，不管是新加入场景的平面还是即将被观察到的空间。包括，增量更新图节点$\mathcal N_{warp}$，然后重新计算层次边拓扑图$\mathcal E$以扩展规格化数据，来容纳新的结点。</p>
<p><strong>Inserting New Deformation Nodes into $\mathcal N_{warp}$</strong><br>在完成非刚体的TSDF的融合之后，可以提取出标准空间中的估计平面为线模型$\mathcal V_c$，给定当前结点们$\mathcal N_{warp}$，可以计算出每个形变函数可以覆盖到提取平面的程度。这需要计算每个顶点到它们的支持结点的向量距离。当距离满足以下条件时，即为不得到支持的顶点：$min_{k\in N(x_c)}(\frac{||dg_v^k-v_c||}{dg_w^k}) \ge 1$. 所有不受支持的点，都会被用半径搜索平均（radius search averaging）的方法进行稀疏降采样，收缩这顶点到新的位置$\tilde{dg_v}$的集合中，这些位置之间至少相隔$\epsilon$的距离。$\epsilon$定义了运动场(motion field)的有效分辨率。每个新的结点中心 $dg ^\star _v {\in} \tilde{dg_v}$ 需要当前变换的初始值，通过当前变形的<strong>DQB</strong>直接得到 $dg_{se3} ^\star \leftarrow \mathcal W_t(dg_v^\star)$ .最后，更新当前变形结点的集合，对应当前的时间$\mathcal N^t_{warp} = \mathcal N_{warp}^{t-1}\cup\{\tilde{dg_v}, \tilde{dg_{se3}}， \tilde{dg_w}\}$. 每次结点更新，也会更新预先计算的$k$临近点域$\mathcal I$.</p>
<p><strong>Updating the regularisation Graph $\mathcal E$</strong><br>给定新跟新的变形结点的集合，构建一个$L \ge 1$层级的规格化图结点层次结构，$l = 0$层是$\mathcal N_{warp}$。计算$l = 1$层是通过在变形场结点$dg_v$上半径搜索再采样到增长抽取的半径$\epsilon \beta ^l, \beta gt 1$，然后通过在当前更新过的$\mathcal W_t$使用<strong>DQB</strong>计算初始结点变换。</p>
<p>接着构建全新的规格化边集$\mathcal E$，从$l = 0$的边开始，到$l = 1$层中的$\mathcal N_{reg}$. 细粒度层($l = 0$)的每个结点都要添加一条到它在粗粒度层$k$临近对应结点的边。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;newcombe大神2015的论文，叼的不行。。。&lt;br&gt;&lt;a href=&quot;https://rse-lab.cs.washington.edu/papers/dynamic-fusion-cvpr-2015.pdf&quot;&gt;论文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="fusion" scheme="http://hengyishu.cn/tags/fusion/"/>
    
      <category term="rgbd" scheme="http://hengyishu.cn/tags/rgbd/"/>
    
      <category term="论文阅读" scheme="http://hengyishu.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Bundle Adjustment光束平差法</title>
    <link href="http://hengyishu.cn/2017/03/08/Bundle-Adjustment%E5%85%89%E6%9D%9F%E5%B9%B3%E5%B7%AE%E6%B3%95/"/>
    <id>http://hengyishu.cn/2017/03/08/Bundle-Adjustment光束平差法/</id>
    <published>2017-03-08T13:52:34.000Z</published>
    <updated>2017-03-08T13:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>bundle adjustment（一般翻译为光束平差法，下称光束平差法）定义为一个问题，这个问题需要同时精细化描述场景几何3D坐标、相对运动参数、和相机用来获取图像的光学特性。<br><a id="more"></a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个从不同视角刻画一系列3D点的图像，bundle adjustment（一般翻译为光束平差法，下称光束平差法）定义为一个问题，这个问题需要同时精细化描述场景几何3D坐标、相对运动参数、和相机用来获取图像的光学特性。解决这个问题需要参照所有点对应图像的投影的最优性表准来完成。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>光束平差法几乎是所有基于特征的3D重建算法的最有一步。它相当于一个3D结构和观察参数（比如相机位置、内参矩阵、和径向畸变）的最优化问题，这个问题可以得到对某些观察中固定的噪声的假设下，最好的重建效果。如果图像偏差是<strong>零均值高斯</strong>的（zero-mean Gaussian），那么平差约束就是<strong>最大似然估计</strong>（Maximum Likelihood Estimator）。它的名字表示从3D特征点发出的集束光线，通过最优化调整对应的结构和观察参数，收敛到各个相机的光学中心。</p>
<h3 id="通常解法-步骤"><a href="#通常解法-步骤" class="headerlink" title="通常解法(步骤)"></a>通常解法(步骤)</h3><p>光束平差归结起来就是观察的图片位置和预测的图片点之间的最小化问题，这个问题通常由大量的非线性实值函数的平方和来表示。最小化问题通常使用非线性的最小二乘算法求解。[Levenberg-Marquardt（莱文贝格马奎特）]方法是最成功的方法之一，它易实现而且可以在大范围的初始参数下都可以成功快速收敛。通过在当前估计的邻近区域对函数的线性化迭代，Levenberg-Marquardt算法涉及称为正规方程的线性系统的解法。当求解在束调整的框架中出现的最小化问题时，由于缺乏针对不同3D点和相机的参数之间的交互，正规方程具有稀疏块结构。 这可以被利用以通过使用Levenberg-Marquardt算法的稀疏变体获得巨大的计算益处，其明确地利用正常方程零点模式，避免存储和操作零元素。</p>
<h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><p>光束平差法相当于联合地精确化初始的相机和结构参数估计集合以找到可以最大精确度预测观察到的图片中的点的位置的参数集合。更正式化一点，假设有$n$个3D点在$m$个视角被观察到，令$x_{ij}$为第$j$幅图片中第$i$个点的投影。令$v_{ij}$为二元值：当点$i$在$j$中可以被看到时，$v_{ij} = 1$，否则为0。同时假设每一个相机$j$使用向量$a_j$进行初始化，每个3D点$i$使用向量$b_i$进行初始化。光束平差法通过调整所有3D点和相机参数来最小化总的重投影(reprojection)的误差，特别地，<br>$$<br>\substack{min\\a_j,b_i}\sum^n_{i=1}\sum^m_{j=1} v_{ij} d(\mathbf Q(\mathbf a_j, \mathbf b_i), \mathbf x_{ij})^2<br>$$<br>其中$Q(\mathbf a_j, \mathbf b_i)$表示图像$j$上的点$i$预测的投影位置，$d(\mathbf x, \mathbf y)$代表了向量$x$和向量$y$之间的欧式距离。明显的看到，光束平差法通过定义，可以容忍丢失图像投影和最小化物理方面的规范。</p>
<hr>
<p>参考:<br><strong>Bundle Adjustment到底是什么？</strong><br><a href="https://www.zhihu.com/question/29082659" target="_blank" rel="external">https://www.zhihu.com/question/29082659</a></p>
<p><strong>Bundle adjustment wiki</strong><br><a href="https://en.wikipedia.org/wiki/Bundle_adjustment" target="_blank" rel="external">https://en.wikipedia.org/wiki/Bundle_adjustment</a></p>
<p><strong>A Generic Sparse Bundle Adjustment C/C++ Package Based on the Levenberg-Marquardt Algorithm</strong><br><a href="http://users.ics.forth.gr/~lourakis/sba/" target="_blank" rel="external">http://users.ics.forth.gr/~lourakis/sba/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bundle adjustment（一般翻译为光束平差法，下称光束平差法）定义为一个问题，这个问题需要同时精细化描述场景几何3D坐标、相对运动参数、和相机用来获取图像的光学特性。&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Bundle Adjustment" scheme="http://hengyishu.cn/tags/Bundle-Adjustment/"/>
    
      <category term="SLAM" scheme="http://hengyishu.cn/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>FAST角点检测 FAST Corner Detection </title>
    <link href="http://hengyishu.cn/2017/03/08/FAST%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B-FAST-Corner-Detection/"/>
    <id>http://hengyishu.cn/2017/03/08/FAST角点检测-FAST-Corner-Detection/</id>
    <published>2017-03-08T08:29:23.000Z</published>
    <updated>2017-03-08T08:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>FAST是一种角点检测方法，用于图像的特征点的提取，然后用在追踪和映射物体等计算机视觉任务中。<br><a id="more"></a></p>
<h3 id="FAST-Features-from-accelerated-segment-test"><a href="#FAST-Features-from-accelerated-segment-test" class="headerlink" title="FAST - Features from accelerated segment test"></a>FAST - Features from accelerated segment test</h3><p>FAST是一种角点检测方法，用于图像的特征点的提取，然后用在追踪和映射物体等计算机视觉任务中。FAST最明显的优势是它的效率。就像它的名字——FAST，它很快并且比其它著名的特征点提取方法，比如SIFT，SUSAN和Harris检测中的DoG(difference of Gaussians)方法。另外，结合机器学习的应用，算法在计算时间和资源上的性能还能够继续提高。</p>
<h3 id="片段测试检测器-Segment-test-detector"><a href="#片段测试检测器-Segment-test-detector" class="headerlink" title="片段测试检测器(Segment test detector)"></a>片段测试检测器(Segment test detector)</h3><p>FAST角点检测算法使用一个16个像素组成的圆(半径为3的<a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm" target="_blank" rel="external">Bresenham圆</a>)来区分候选点p是否是角点。16个像素按照顺时针方向以此标记为1-16号。如果连续的N的点都比p点的亮度值加上一个阈值t高或者比p点的亮度值减去阈值t低，那么就认为p是一个角点。这个条件可以写作：</p>
<ul>
<li>条件1: N个连续点的集合S, $\forall x \in S$, x点的亮度$I_x&gt;I_p + 阈值t$</li>
<li>条件2: N个连续点的集合S, $\forall x \in S$, x点的亮度$I_x&lt;I_p - 阈值t$</li>
</ul>
<p>没有机器学习参与的情况下，N通常选择为12。在排除候选点的时候，应用一些方法来保证算法的性能。</p>
<h3 id="高速检测"><a href="#高速检测" class="headerlink" title="高速检测"></a>高速检测</h3><p>通过先后检测编号为1，9，5，13来快速排除非角点的候选点。因为至少有12个点满足上述的两个条件时，p才是角点，所以这四个点中至少要有三个比候选的点同时亮（条件1）或者暗（条件2）。<br>首先检测1，9，如果$I_1, I_9$都在区间$[I_p - t, I_p + t]$内，那么候选点必然不是角点。<br>否则就检测5，13号点，检查这四个点是否有三个同时比$I_p + t$亮或者同时比$I_p - t$暗。<br>如果4个点中有3个同时比p亮或者暗，那么再检查剩余的点，看是否真正满足角点定义中的条件。<br>这样的方法相比完全按照定义的条件进行检测要快得多。但是，这样的做法仍然有短板：</p>
<ol>
<li>当N&lt;12时，这里介绍的高速检测方法就失效了</li>
<li>算法的效率受到待测点（圆上的点）的选择和顺序。但是考虑角点外部的分布，选择的点不可能是最优的</li>
<li>多个特征点会聚集在一起</li>
</ol>
<p>使用机器学习的方法，可以帮助克服上述短板。具体可以参考<a href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test" target="_blank" rel="external">wiki</a>及<a href="http://lanl.arxiv.org/pdf/0810.2434" target="_blank" rel="external">论文</a>。</p>
<h3 id="非极大值抑制-Non-maximum-suppression"><a href="#非极大值抑制-Non-maximum-suppression" class="headerlink" title="非极大值抑制(Non-maximum suppression)"></a>非极大值抑制(Non-maximum suppression)</h3><p>这个方法用来去除集束的特征点，去掉紧邻的特征点中角点强度较小的点，解决了上述的第三个短板。</p>
<p>定义： 如果N固定，称能使点p仍然为角点的最大的t为<strong>角点强度</strong>。两种方法可以用来找到<strong>角点强度</strong>：</p>
<ul>
<li>二叉树可以用来搜索t的最大值。每次将一个不同的t放入决策树中时，决策树会试图找到最大的t，那个t就可以视为角点强度</li>
<li>另一种方法是在每次高速检测通过时，t递增一个小的量，最终可以找到t的最大值。</li>
</ul>
<p>参考：<br><a href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test" target="_blank" rel="external">https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test</a><br><a href="http://www.cnblogs.com/ronny/p/4078710.html" target="_blank" rel="external">http://www.cnblogs.com/ronny/p/4078710.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FAST是一种角点检测方法，用于图像的特征点的提取，然后用在追踪和映射物体等计算机视觉任务中。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习记录" scheme="http://hengyishu.cn/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Cuda 8.0 in Qt 5.8 with VS2015 32bit</title>
    <link href="http://hengyishu.cn/2017/02/22/Cuda-8-0-in-Qt-5-8-with-VS2015-32bit/"/>
    <id>http://hengyishu.cn/2017/02/22/Cuda-8-0-in-Qt-5-8-with-VS2015-32bit/</id>
    <published>2017-02-22T07:25:11.000Z</published>
    <updated>2017-03-08T08:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>把cuda应用到Qt中没有官方插件也没有完整的教程，网上找到的都是cuda4.0左右版本的教程，我用的是cuda8.0，Qt5.8。自己摸索了一下配置过程。<br><a id="more"></a></p>
<h2 id="来自stackoverflow的-pro文件"><a href="#来自stackoverflow的-pro文件" class="headerlink" title="来自stackoverflow的.pro文件"></a>来自stackoverflow的.pro文件</h2><p>我的Qt工程结构如下：</p>
<pre><code>CUDAinQt\
    CUDAinQt.pro
    src\
        main.cpp
        cuda\
            cudaTest.cu
</code></pre><p>参考stackoverflow的<a href="http://stackoverflow.com/questions/12266264/compiling-cuda-code-in-qt-creator-on-windows" target="_blank" rel="external">一篇回答</a>中的.pro文件，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">TARGET = TestCUDA</div><div class="line"></div><div class="line"># Define output directories</div><div class="line">DESTDIR = release</div><div class="line">OBJECTS_DIR = release/obj</div><div class="line">CUDA_OBJECTS_DIR = release/cuda</div><div class="line"></div><div class="line"># Source files</div><div class="line">SOURCES += src/main.cpp</div><div class="line"></div><div class="line"># This makes the .cu files appear in your project</div><div class="line">OTHER_FILES +=  vectorAddition.cu</div><div class="line"></div><div class="line"># CUDA settings &lt;-- may change depending on your system</div><div class="line">CUDA_SOURCES += src/cuda/vectorAddition.cu</div><div class="line">CUDA_SDK = "C:/ProgramData/NVIDIA Corporation/NVIDIA GPU Computing SDK 4.2/C"   # Path to cuda SDK install</div><div class="line">CUDA_DIR = "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v4.2"            # Path to cuda toolkit install</div><div class="line">SYSTEM_NAME = Win32         # Depending on your system either 'Win32', 'x64', or 'Win64'</div><div class="line">SYSTEM_TYPE = 32            # '32' or '64', depending on your system</div><div class="line">CUDA_ARCH = sm_11           # Type of CUDA architecture, for example 'compute_10', 'compute_11', 'sm_10'</div><div class="line">NVCC_OPTIONS = --use_fast_math</div><div class="line"></div><div class="line"># include paths</div><div class="line">INCLUDEPATH += $$CUDA_DIR/include \</div><div class="line">               $$CUDA_SDK/common/inc/ \</div><div class="line">               $$CUDA_SDK/../shared/inc/</div><div class="line"></div><div class="line"># library directories</div><div class="line">QMAKE_LIBDIR += $$CUDA_DIR/lib/$$SYSTEM_NAME \</div><div class="line">                $$CUDA_SDK/common/lib/$$SYSTEM_NAME \</div><div class="line">                $$CUDA_SDK/../shared/lib/$$SYSTEM_NAME</div><div class="line"># Add the necessary libraries</div><div class="line">LIBS += -lcuda -lcudart</div><div class="line"></div><div class="line"># The following library conflicts with something in Cuda</div><div class="line">QMAKE_LFLAGS_RELEASE = /NODEFAULTLIB:msvcrt.lib</div><div class="line">QMAKE_LFLAGS_DEBUG   = /NODEFAULTLIB:msvcrtd.lib</div><div class="line"></div><div class="line"># The following makes sure all path names (which often include spaces) are put between quotation marks</div><div class="line">CUDA_INC = $$join(INCLUDEPATH,'" -I"','-I"','"')</div><div class="line"></div><div class="line"># Configuration of the Cuda compiler</div><div class="line">CONFIG(debug, debug|release) &#123;</div><div class="line">    # Debug mode</div><div class="line">    cuda_d.input = CUDA_SOURCES</div><div class="line">    cuda_d.output = $$CUDA_OBJECTS_DIR/$&#123;QMAKE_FILE_BASE&#125;_cuda.o</div><div class="line">    cuda_d.commands = $$CUDA_DIR/bin/nvcc.exe -D_DEBUG $$NVCC_OPTIONS $$CUDA_INC $$LIBS --machine $$SYSTEM_TYPE -arch=$$CUDA_ARCH -c -o $&#123;QMAKE_FILE_OUT&#125; $&#123;QMAKE_FILE_NAME&#125;</div><div class="line">    cuda_d.dependency_type = TYPE_C</div><div class="line">    QMAKE_EXTRA_COMPILERS += cuda_d</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    # Release mode</div><div class="line">    cuda.input = CUDA_SOURCES</div><div class="line">    cuda.output = $$CUDA_OBJECTS_DIR/$&#123;QMAKE_FILE_BASE&#125;_cuda.o</div><div class="line">    cuda.commands = $$CUDA_DIR/bin/nvcc.exe $$NVCC_OPTIONS $$CUDA_INC $$LIBS --machine $$SYSTEM_TYPE -arch=$$CUDA_ARCH -c -o $&#123;QMAKE_FILE_OUT&#125; $&#123;QMAKE_FILE_NAME&#125;</div><div class="line">    cuda.dependency_type = TYPE_C</div><div class="line">    QMAKE_EXTRA_COMPILERS += cuda</div></pre></td></tr></table></figure></p>
<p>可以由<code>CUDA_SDK</code>,<code>CUDA_DIR</code>看到答主的回答适用于cuda4.2，依照他的设置马上就会发现cuda8.0中没有<code>CUDA_SDK</code>对应的文件。google一下发现新版cuda将这两个地方的内容放在了一起，也就是将上述文件中<code>CUDA_DIR</code>配置到自己相对应的toolkit目录即可，把所有包含<code>CUDA_SDK</code>的行删掉就行了。<code>CUDA_SDK</code>主要是跟编译时的lib相关，所以也没有多少行代码跟他相关，删掉就行。</p>
<h2 id="找不到-cuda-o文件"><a href="#找不到-cuda-o文件" class="headerlink" title="找不到*_cuda.o文件"></a>找不到*_cuda.o文件</h2><p>接着，仍然引用那篇回答中将main.cpp和cudaTest.cu源码写好，进行编译。提示错误，说是找不到.cu文件的.obj文件，查看<strong>编译输出</strong>，看来问题出在nvcc的参数上面。可以发现上述4、5、6行定义了目标文件夹，但是前缀都是release，然而我的实验一直都是在debug模式下做的，所以这里应该有问题。</p>
<p>将</p>
<pre><code>DESTDIR = release
OBJECTS_DIR = release/obj
CUDA_OBJECTS_DIR = release/cuda
</code></pre><p>放在config(…){…}else{…}中，针对debug和release版本，做不同的定义。将前缀分别改为debug和release即可。</p>
<h2 id="检测到“RuntimeLibrary”的不匹配项-值“MDd-DynamicDebug”不匹配值“MTd-StaticDebug”"><a href="#检测到“RuntimeLibrary”的不匹配项-值“MDd-DynamicDebug”不匹配值“MTd-StaticDebug”" class="headerlink" title="检测到“RuntimeLibrary”的不匹配项: 值“MDd_DynamicDebug”不匹配值“MTd_StaticDebug”"></a>检测到“RuntimeLibrary”的不匹配项: 值“MDd_DynamicDebug”不匹配值“MTd_StaticDebug”</h2><p>修改好之后有新的问题，连接错误，提示</p>
<pre><code>检测到“RuntimeLibrary”的不匹配项:值“MDd_DynamicDebug”不匹配值“MTd_StaticDebug”(在cudaTest_cuda.o中)
</code></pre><p>这是动态编译文件和静态编译文件不匹配导致的，在VS中很容易修改，但是Qt Creator中我还真不知道怎么办。查了查资料有一种办法，在nvcc后面设置参数，将cudart库的编译设置为static就行。</p>
<p>参考： <a href="http://stackoverflow.com/questions/26205608/compile-cuda-file-error-runtime-library-mismatch-value-mdd-dynamicdebug-doe" target="_blank" rel="external">http://stackoverflow.com/questions/26205608/compile-cuda-file-error-runtime-library-mismatch-value-mdd-dynamicdebug-doe</a></p>
<h2 id="Value-‘sm-10’-is-not-defined-for-option-‘gpu-architecture’"><a href="#Value-‘sm-10’-is-not-defined-for-option-‘gpu-architecture’" class="headerlink" title="Value ‘sm_10’ is not defined for option ‘gpu-architecture’"></a>Value ‘sm_10’ is not defined for option ‘gpu-architecture’</h2><p>‘sm_10’是nvcc中的参数-arch的一个值，新版cuda中这个值已经不支持sm_10了，新的值可以通过nvcc –help命令查看，我这里选用了sm_50。参数的含义在help文档中也有说明。</p>
<p>附上我截取的-arch参数说明。</p>
<pre><code>Specify the name of the class of NVIDIA &apos;virtual&apos; GPU architecture for which the CUDA input files must be compiled.
With the exception as described for the shorthand below, the architecture specified with this option must be a &apos;virtual&apos; architecture (such as compute_50).
Normally, this option alone does not trigger assembly of the generated PTX for a &apos;real&apos; architecture (that is the role of nvcc option &apos;--gpu-code&apos;, 
see below); rather, its purpose is to control preprocessing and compilation of the input to PTX.
For convenience, in case of simple nvcc compilations, the following shorthand is supported.  If no value for option &apos;--gpu-code&apos; is specified, then the
value of this option defaults to the value of &apos;--gpu-architecture&apos;.  In this
situation, as only exception to the description above, the value specified
for &apos;--gpu-architecture&apos; may be a &apos;real&apos; architecture (such as a sm_50),
in which case nvcc uses the specified &apos;real&apos; architecture and its closest
&apos;virtual&apos; architecture as effective architecture values.  For example, &apos;nvcc
--gpu-architecture=sm_50&apos; is equivalent to &apos;nvcc --gpu-architecture=compute_50
--gpu-code=sm_50,compute_50&apos;.
Allowed values for this option:  &apos;compute_20&apos;,&apos;compute_30&apos;,&apos;compute_32&apos;,
&apos;compute_35&apos;,&apos;compute_37&apos;,&apos;compute_50&apos;,&apos;compute_52&apos;,&apos;compute_53&apos;,&apos;compute_60&apos;,
&apos;compute_61&apos;,&apos;compute_62&apos;,&apos;sm_20&apos;,&apos;sm_21&apos;,&apos;sm_30&apos;,&apos;sm_32&apos;,&apos;sm_35&apos;,&apos;sm_37&apos;,
&apos;sm_50&apos;,&apos;sm_52&apos;,&apos;sm_53&apos;,&apos;sm_60&apos;,&apos;sm_61&apos;,&apos;sm_62&apos;.
</code></pre><p>参考：<a href="https://devtalk.nvidia.com/default/topic/762051/compile-issues/" target="_blank" rel="external">https://devtalk.nvidia.com/default/topic/762051/compile-issues/</a></p>
<h2 id="我的-pro文件"><a href="#我的-pro文件" class="headerlink" title="我的.pro文件"></a>我的.pro文件</h2><pre><code>QT       += core

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = CUDAinQt

SOURCES += src/main.cpp

# This makes the .cu files appear in your project
OTHER_FILES += cudaTest.cu

# CUDA settings &lt;-- may change depending on your system
CUDA_SOURCES += src/cuda/cudaTest.cu
#CUDA_SDK = &quot;C:/ProgramData/NVIDIA Corporation/NVIDIA GPU Computing SDK 4.2/C&quot;   # Path to cuda SDK install
CUDA_DIR = &quot;C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v8.0&quot;            # Path to cuda toolkit install
SYSTEM_NAME = Win32         # Depending on your system either &apos;Win32&apos;, &apos;x64&apos;, or &apos;Win64&apos;
SYSTEM_TYPE = 32            # &apos;32&apos; or &apos;64&apos;, depending on your system
CUDA_ARCH = compute_50           # Type of CUDA architecture, for example &apos;compute_10&apos;, &apos;compute_11&apos;, &apos;sm_10&apos;
CUDA_CODE = sm_50
NVCC_OPTIONS = --use_fast_math

# include paths
INCLUDEPATH += $$CUDA_DIR/include

# library directories
QMAKE_LIBDIR += $$CUDA_DIR/lib/$$SYSTEM_NAME

# Add the necessary libraries
LIBS += -lcuda -lcudart

# The following library conflicts with something in Cuda
QMAKE_LFLAGS_RELEASE = /NODEFAULTLIB:msvcrt.lib
QMAKE_LFLAGS_DEBUG   = /NODEFAULTLIB:msvcrtd.lib

# The following makes sure all path names (which often include spaces) are put between quotation marks
CUDA_INC = $$join(INCLUDEPATH,&apos;&quot; -I&quot;&apos;,&apos;-I&quot;&apos;,&apos;&quot;&apos;)

# Configuration of the Cuda compiler (NVCC)

# MSVCRT link option (static or dynamic, it must be the same with your Qt SDK link option)
MSVCRT_LINK_FLAG_DEBUG = &quot;/MDd&quot;
MSVCRT_LINK_FLAG_RELEASE = &quot;/MD&quot;

CONFIG(debug, debug|release) {
    # Debug mode
    DESTDIR = debug
    OBJECTS_DIR = debug/obj
    CUDA_OBJECTS_DIR = debug/cuda
    cuda_d.input = CUDA_SOURCES
    cuda_d.output = $$CUDA_OBJECTS_DIR/${QMAKE_FILE_BASE}_cuda.o
    cuda_d.commands = $$CUDA_DIR/bin/nvcc.exe -D_DEBUG $$NVCC_OPTIONS $$CUDA_INC $$LIBS \
                      --machine $$SYSTEM_TYPE -arch=$$CUDA_ARCH -code=$$CUDA_CODE \
                      --compile -cudart static -g -DWIN32 -D_MBCS \
                      -Xcompiler &quot;/wd4819,/EHsc,/W3,/nologo,/O2,/Zi&quot; \
                      -Xcompiler $$MSVCRT_LINK_FLAG_RELEASE \
                      -c -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
    cuda_d.dependency_type = TYPE_C
    QMAKE_EXTRA_COMPILERS += cuda_d
}
else {
    # Release mode
    DESTDIR = release
    OBJECTS_DIR = release/obj
    CUDA_OBJECTS_DIR = release/cuda
    cuda.input = CUDA_SOURCES
    cuda.output = $$CUDA_OBJECTS_DIR/${QMAKE_FILE_BASE}_cuda.o
#    cuda.commands = $$CUDA_DIR/bin/nvcc.exe $$NVCC_OPTIONS $$CUDA_INC $$LIBS --machine $$SYSTEM_TYPE -arch=$$CUDA_ARCH -code=$$CUDA_CODE -c -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
    cuda.commands = $$CUDA_DIR/bin/nvcc.exe $$NVCC_OPTIONS $$CUDA_INC $$LIBS \
                    --machine $$SYSTEM_TYPE -arch=$$CUDA_ARCH -code=$$CUDA_CODE \
                    --compile -cudart static -DWIN32 -D_MBCS \
                    -Xcompiler &quot;/wd4819,/EHsc,/W3,/nologo,/O2,/Zi&quot; \
                    -Xcompiler $$MSVCRT_LINK_FLAG_RELEASE \
                    -c -o ${QMAKE_FILE_OUT} ${QMAKE_FILE_NAME}
    cuda.dependency_type = TYPE_C
    QMAKE_EXTRA_COMPILERS += cuda
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把cuda应用到Qt中没有官方插件也没有完整的教程，网上找到的都是cuda4.0左右版本的教程，我用的是cuda8.0，Qt5.8。自己摸索了一下配置过程。&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="cuda qt" scheme="http://hengyishu.cn/tags/cuda-qt/"/>
    
  </entry>
  
  <entry>
    <title>windows高效软件</title>
    <link href="http://hengyishu.cn/2017/02/18/%E6%8F%90%E9%AB%98windows%E4%BD%BF%E7%94%A8%E4%BD%93%E6%A3%80%E7%9A%84%E8%BD%AF%E4%BB%B6/"/>
    <id>http://hengyishu.cn/2017/02/18/提高windows使用体检的软件/</id>
    <published>2017-02-18T02:35:13.000Z</published>
    <updated>2017-02-18T02:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新一下，这半年来有一些新的软件可以推荐。<br><a id="more"></a></p>
<h2 id="cmd-markdown"><a href="#cmd-markdown" class="headerlink" title="cmd markdown"></a>cmd markdown</h2><p>支持标准md语法，支持mathjax公式，写博客，写学习笔记都很实用。<br>有web版，pc版，pc版支持离线写作。自带同步，到哪都能用，相当方便。<br>唯一有缺憾的就是移动端编辑界面支持不太好，不过没有太大影响。</p>
<p><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">网页版cmd markdown</a><br><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">下载客户端</a></p>
<h2 id="欧陆词典"><a href="#欧陆词典" class="headerlink" title="欧陆词典"></a>欧陆词典</h2><p>没有广告，多端同步，看腻了某道词典广告的同学可以试一下这个，可能有些功能稍微弱一点，但是对日常查单词足够了（毕竟翻译的话我就找度娘谷哥了XD）。<br>跨平台，linux没有，其它主流平台都有。<br><a href="http://www.eudic.net/eudic/windows.aspx" target="_blank" rel="external">欧陆词典 - Windows平台上最好用的词典软件，支持海量扩充词库</a></p>
<hr>
<p>以下是原文（有改动）</p>
<p>好久没写博客了，上次写的东西还是3月多的，自己真是越来越懒了。<br>之前在知乎看到很多关于“如何优雅地windows”的讨论，自己看了试了一些，这里结合自己的经历分享一下体验。<br>首先，自己桌面镇一下~<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/5-29%2Fdesktop.png" alt="桌面" title="桌面"><br>桌面简单为主，应用程序都放在了开始菜单。我关闭了小娜的按钮，左上角放了一个下拉关机，上面中间是经常用到的程序，右边有一些需要用到但是频率不那么高的快捷方式（文件夹）。需要干活的时候，桌面上放一些需要用到的东西的快捷方式，完事之后就删掉，方便！</p>
<h2 id="Clover-（不再推荐，有广告，而且发现win10自己的窗口管理习惯了的话效率也蛮高的）"><a href="#Clover-（不再推荐，有广告，而且发现win10自己的窗口管理习惯了的话效率也蛮高的）" class="headerlink" title="Clover （不再推荐，有广告，而且发现win10自己的窗口管理习惯了的话效率也蛮高的）"></a><del>Clover</del> （不再推荐，有广告，而且发现win10自己的窗口管理习惯了的话效率也蛮高的）</h2><p>国产软件，不过很久没更新了，官方最高支持到win8，但是我win10一直在用，偶尔会崩溃，win7据说没问题。<br>文件夹的收藏是我一直很重要的一个需求，因为经常需要在很多文件夹里面来回翻找，没用这个软件之前都是一个个去点，clover添加收藏之后简直爽爆。另外，标签页也很漂亮，比起其他同样功能的软件QtTabbar要好很多。<br>官网：<br><a href="http://cn.ejie.me/" title="易捷科技" target="_blank" rel="external">Clover2</a></p>
<h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><p>这是个好看版的everything，也是款效率提升神器。虽然win10的整合了小娜，也可以进行全局搜索，但是感觉没有那么顺畅，就用了listary。listary可以设置全局快捷键（我是win + F）进行搜索，而且搜索速度相当快。</p>
<p><img src="http://7xrsid.com1.z0.glb.clouddn.com/5-29%2Flistary1.png" alt="Listary全局搜索" title="Listary全局搜索"><br><img src="http://7xrsid.com1.z0.glb.clouddn.com/5-29%2Flistary2.png" alt="Listary2" title="Listary"></p>
<p>官网地址:<br><a href="http://www.listary.com/" title="Listary" target="_blank" rel="external">Listary: File Search &amp; App Launcher</a></p>
<h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><p>不多说，确实好用，情怀加分。</p>
<p><a href="http://music.163.com/#/download" title="Netease Music" target="_blank" rel="external">网易云音乐</a></p>
<h2 id="QQ轻聊版"><a href="#QQ轻聊版" class="headerlink" title="QQ轻聊版"></a>QQ轻聊版</h2><p>去掉烦人的广告和QQ秀，也没有QQ空间评论提醒，空间依赖症慎用。</p>
<p><a href="http://im.qq.com/lightqq/" title="QQ light" target="_blank" rel="external">QQ轻聊版</a></p>
<h2 id="电脑管家"><a href="#电脑管家" class="headerlink" title="电脑管家"></a>电脑管家</h2><p>好像杀毒能力不怎么样？可以用来升级软件用。</p>
<p><a href="http://guanjia.qq.com/" target="_blank" rel="external">腾讯电脑管家</a></p>
<h2 id="potplayer"><a href="#potplayer" class="headerlink" title="potplayer"></a>potplayer</h2><p>绿色全能播放器(手动笑脸)</p>
<p><a href="http://www.potplayer.org/" target="_blank" rel="external">PotPlayer</a></p>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>谷歌大法好！</p>
<h2 id="Latern"><a href="#Latern" class="headerlink" title="Latern"></a>Latern</h2><p>fan qiang神器,2016开始就不免费了，每个月有800m流量，其它需要充值，我现在用SS(滑稽:P<br><a href="https://getlantern.org/" target="_blank" rel="external">Get Lantern</a></p>
<h2 id="f-lux"><a href="#f-lux" class="headerlink" title="f.lux"></a>f.lux</h2><p>调节屏幕色温，长时间对着屏幕也不会很难受。</p>
<p><a href="https://justgetflux.com/" target="_blank" rel="external">f.lux下载</a></p>
<h2 id="notepad"><a href="#notepad" class="headerlink" title="notepad++"></a>notepad++</h2><p>多功能小巧的编辑器。<br><a href="https://notepad-plus-plus.org/" target="_blank" rel="external">notepad++</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新一下，这半年来有一些新的软件可以推荐。&lt;br&gt;
    
    </summary>
    
      <category term="日常" scheme="http://hengyishu.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="效率" scheme="http://hengyishu.cn/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="神器" scheme="http://hengyishu.cn/tags/%E7%A5%9E%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 入门</title>
    <link href="http://hengyishu.cn/2017/02/18/CUDA-%E5%85%A5%E9%97%A8/"/>
    <id>http://hengyishu.cn/2017/02/18/CUDA-入门/</id>
    <published>2017-02-18T02:19:48.000Z</published>
    <updated>2017-02-18T02:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>三维重建离不开大规模的矩阵运算，合理编程利用GPU可以加速这些运算的效率。</p>
<a id="more"></a>
<h2 id="CUDA教程"><a href="#CUDA教程" class="headerlink" title="CUDA教程"></a>CUDA教程</h2><p>参考<br><a href="http://blog.csdn.net/sunmc1204953974/article/details/51074102" target="_blank" rel="external">http://blog.csdn.net/sunmc1204953974/article/details/51074102</a><br>博客中结合例子，把GPU内的基本概念做了比较详尽的介绍，对于入门很友好。</p>
<h3 id="让VS-IntelliSense识别cuda函数、变量"><a href="#让VS-IntelliSense识别cuda函数、变量" class="headerlink" title="让VS IntelliSense识别cuda函数、变量"></a>让VS IntelliSense识别cuda函数、变量</h3><p><strong>针对device代码中的变量，比如threadId.x等</strong><br>加入如下#include语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;device_launch_parameters.h&gt;</div></pre></td></tr></table></figure></p>
<p><strong>针对device线程同步函数__syncthreads()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#pragma once</div><div class="line">#ifdef __INTELLISENSE__</div><div class="line">void __syncthreads();</div><div class="line">...</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h3 id="CUDA调试困难？？"><a href="#CUDA调试困难？？" class="headerlink" title="CUDA调试困难？？"></a>CUDA调试困难？？</h3><p>linux下使用 cuda gdb<br>windows下使用 nsight</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三维重建离不开大规模的矩阵运算，合理编程利用GPU可以加速这些运算的效率。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="CUDA, GPU编程" scheme="http://hengyishu.cn/tags/CUDA-GPU%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Debug in visual c++</title>
    <link href="http://hengyishu.cn/2017/02/18/Debug-in-visual-c/"/>
    <id>http://hengyishu.cn/2017/02/18/Debug-in-visual-c/</id>
    <published>2017-02-18T02:12:00.000Z</published>
    <updated>2017-02-18T02:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究师兄的代码，编译一遍挺久，所以趁此机会了解一下相关debug的技巧和方法，有助于提高自己的开发效率。</p>
<a id="more"></a>
<h2 id="VS调试器调试技巧"><a href="#VS调试器调试技巧" class="headerlink" title="VS调试器调试技巧"></a>VS调试器调试技巧</h2><p><a href="http://blog.jobbole.com/33865/" target="_blank" rel="external">http://blog.jobbole.com/33865/</a><br><a href="http://hovertree.com/h/bjaf/pbqy1f1k.htm" target="_blank" rel="external">http://hovertree.com/h/bjaf/pbqy1f1k.htm</a><br><a href="http://blog.jobbole.com/45249/" target="_blank" rel="external">http://blog.jobbole.com/45249/</a></p>
<ul>
<li>调用堆栈</li>
<li>鼠标悬停查看变量信息</li>
<li>调试过程中直接给变量赋值</li>
<li>拖动黄色箭头改变程序运行流程</li>
<li>通过<code>ptr+offset,count</code>添加变量监视(watch)</li>
</ul>
<h2 id="断点和追踪点"><a href="#断点和追踪点" class="headerlink" title="断点和追踪点"></a>断点和追踪点</h2><p><a href="https://msdn.microsoft.com/zh-cn/library/232dxah7(v=vs.90).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/232dxah7(v=vs.90).aspx</a></p>
<h2 id="MACRO-ASSERT、TRACE、VERIFY"><a href="#MACRO-ASSERT、TRACE、VERIFY" class="headerlink" title="MACRO - ASSERT、TRACE、VERIFY"></a>MACRO - ASSERT、TRACE、VERIFY</h2><p><a href="http://blog.csdn.net/chocolateconanlan/article/details/4061545" target="_blank" rel="external">http://blog.csdn.net/chocolateconanlan/article/details/4061545</a><br>博客最后部分<br>以及MSDN<br><a href="https://msdn.microsoft.com/en-us/library/9sb57dw4.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/9sb57dw4.aspx</a></p>
<blockquote>
<p><strong>Syntax语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">assert(   </div><div class="line">   expression   </div><div class="line">);  </div><div class="line">void _assert(  </div><div class="line">   char const* message,  </div><div class="line">   char const* filename,  </div><div class="line">   unsigned line  </div><div class="line">);  </div><div class="line">void _wassert(  </div><div class="line">   wchar_t const* message,  </div><div class="line">   wchar_t const* filename,  </div><div class="line">   unsigned line  </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><strong>Parameters参数</strong><br>expression<br>: A scalar expression (including pointer expressions) that evaluates to nonzero (true) or 0 (false).</p>
</blockquote>
<p>message<br>: The message to display.</p>
<p>filename<br>: The name of the source file the assertion failed in.</p>
<p>line<br>: The line number in the source file of the failed assertion.</p>
<h2 id="MACRO-OutputDebugString"><a href="#MACRO-OutputDebugString" class="headerlink" title="MACRO - OutputDebugString"></a>MACRO - OutputDebugString</h2><blockquote>
<p>You can use OutputDebugString. OutputDebugString is a macro that depending on your build options either maps to <code>OutputDebugStringA(char const*)</code>or <code>OutputDebugStringW(wchar_t const*)</code>. In the later case you will have to supply a wide character string to the function. To create a wide character literal you can use the L prefix:<br><code>OutputDebugStringW(L&quot;My output string.&quot;);</code><br>Normally you will use the macro version together with the _T macro like this:<br><code>OutputDebugString(_T(&quot;My output string.&quot;));</code><br>If you project is configured to build for UNICODE it will expand into:<br><code>OutputDebugStringW(L&quot;My output string.&quot;);</code><br>If you are not building for UNICODE it will expand into:<br><code>OutputDebugStringA(&quot;My output string.&quot;);</code></p>
</blockquote>
<h2 id="Logging-Class"><a href="#Logging-Class" class="headerlink" title="Logging Class"></a>Logging Class</h2><p>Logging Framework from Dr.p<br><a href="http://www.drdobbs.com/cpp/logging-in-c/201804215" target="_blank" rel="external">http://www.drdobbs.com/cpp/logging-in-c/201804215</a></p>
<p>简单的stderr debug类，来自<br><a href="http://stackoverflow.com/questions/6168107/how-to-implement-a-good-debug-logging-feature-in-a-project" target="_blank" rel="external">http://stackoverflow.com/questions/6168107/how-to-implement-a-good-debug-logging-feature-in-a-project</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#ifndef _LOGGER_HPP_</div><div class="line">#define _LOGGER_HPP_</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line"></div><div class="line">/* consider adding boost thread id since we&apos;ll want to know whose writting and</div><div class="line"> * won&apos;t want to repeat it for every single call */</div><div class="line"></div><div class="line">/* consider adding policy class to allow users to redirect logging to specific</div><div class="line"> * files via the command line</div><div class="line"> */</div><div class="line"></div><div class="line">enum loglevel_e</div><div class="line">    &#123;logERROR, logWARNING, logINFO, logDEBUG, logDEBUG1, logDEBUG2, logDEBUG3, logDEBUG4&#125;;</div><div class="line"></div><div class="line">class logIt</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    logIt(loglevel_e _loglevel = logERROR) &#123;</div><div class="line">        _buffer &lt;&lt; _loglevel &lt;&lt; &quot; :&quot; </div><div class="line">            &lt;&lt; std::string(</div><div class="line">                _loglevel &gt; logDEBUG </div><div class="line">                ? (_loglevel - logDEBUG) * 4 </div><div class="line">                : 1</div><div class="line">                , &apos; &apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    template &lt;typename T&gt;</div><div class="line">    logIt &amp; operator&lt;&lt;(T const &amp; value)</div><div class="line">    &#123;</div><div class="line">        _buffer &lt;&lt; value;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~logIt()</div><div class="line">    &#123;</div><div class="line">        _buffer &lt;&lt; std::endl;</div><div class="line">        // This is atomic according to the POSIX standard</div><div class="line">        // http://www.gnu.org/s/libc/manual/html_node/Streams-and-Threads.html</div><div class="line">        std::cerr &lt;&lt; _buffer.str();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    std::ostringstream _buffer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extern loglevel_e loglevel;</div><div class="line"></div><div class="line">#define log(level) \</div><div class="line">if (level &gt; loglevel) ; \</div><div class="line">else logIt(level)</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// define and turn off for the rest of the test suite</div><div class="line">loglevel_e loglevel = logERROR;</div><div class="line"></div><div class="line">void logTest(void) &#123;</div><div class="line">    loglevel_e loglevel_save = loglevel;</div><div class="line"></div><div class="line">    loglevel = logDEBUG4;</div><div class="line"></div><div class="line">    log(logINFO) &lt;&lt; &quot;foo &quot; &lt;&lt; &quot;bar &quot; &lt;&lt; &quot;baz&quot;;</div><div class="line"></div><div class="line">    int count = 3;</div><div class="line">    log(logDEBUG) &lt;&lt; &quot;A loop with &quot;    &lt;&lt; count &lt;&lt; &quot; iterations&quot;;</div><div class="line">    for (int i = 0; i != count; ++i)</div><div class="line">    &#123;</div><div class="line">        log(logDEBUG1) &lt;&lt; &quot;the counter i = &quot; &lt;&lt; i;</div><div class="line">        log(logDEBUG2) &lt;&lt; &quot;the counter i = &quot; &lt;&lt; i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loglevel = loglevel_save;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究师兄的代码，编译一遍挺久，所以趁此机会了解一下相关debug的技巧和方法，有助于提高自己的开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="VisualC++" scheme="http://hengyishu.cn/tags/VisualC/"/>
    
      <category term="Debug" scheme="http://hengyishu.cn/tags/Debug/"/>
    
      <category term="VisualStudio" scheme="http://hengyishu.cn/tags/VisualStudio/"/>
    
  </entry>
  
  <entry>
    <title>迭代最近点方法ICP</title>
    <link href="http://hengyishu.cn/2017/02/16/%E8%BF%AD%E4%BB%A3%E6%9C%80%E8%BF%91%E7%82%B9%E6%96%B9%E6%B3%95ICP/"/>
    <id>http://hengyishu.cn/2017/02/16/迭代最近点方法ICP/</id>
    <published>2017-02-16T08:57:57.000Z</published>
    <updated>2017-02-18T02:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>ICP迭代最近点方法，是三维建模中将点云模型对齐的一种常用方法。</p>
<a id="more"></a>
<h2 id="ICP算法"><a href="#ICP算法" class="headerlink" title="ICP算法"></a>ICP算法</h2><p><a href="https://en.wikipedia.org/wiki/Iterative_closest_point" target="_blank" rel="external">wiki</a></p>
<blockquote>
<p>ICP算法中，一幅点云，称为<strong>参考</strong>或者<strong>目标点云</strong>，是固定不动的。另一幅，称为<strong>源点云</strong>，被算法变换到与参考点云最佳匹配的位置。算法迭代的得出变换矩阵（平移和旋转的组合），这个矩阵需要最小化从源到目标点云的距离。</p>
<p><strong>输入：</strong> 目标点云和源点云；两幅点云对齐的评判标准（非必须）；终止迭代的条件<br><strong>输出：</strong>计算的变换矩阵</p>
<p><strong>主要步骤：</strong></p>
<ol>
<li>对源点云中的每一个点，找到目标点云中的最近点，作为匹配位置</li>
<li>使用均方差函数估算上述步骤找到的、可以将源点云变换到上一步找到的匹配位置的刚性变换。</li>
<li>对源点云应用上述刚性变换</li>
<li>迭代</li>
</ol>
</blockquote>
<p><a href="http://101.96.8.164/www.cs.princeton.edu/~smr/papers/icpstability.pdf" target="_blank" rel="external">数学解释与稳定性分析</a></p>
<blockquote>
<p>$$<br>E = \Sigma_i [(p_i - q_i) \cdot<br>n_i + t \cdot n_i +\\<br>\alpha(p_{i,y}n_{i,z} - p_{i,z}n_{i,y}) +<br>\\ \beta (p_{i,z}n_{i,x} - p_{i,x}n_{i,z}) + \\ \gamma(p_{i,x}n_{i,y} - p_{i,y}n_{i,x})] ^ 2<br>$$<br>设 $c = p \times n$ 且<br>$$<br>r =<br>\begin{pmatrix}<br>\alpha \\ \beta \\ \gamma<br>\end{pmatrix}<br>$$<br>则E可以写为<br>$$<br>E = \Sigma_i[(p_i - q_i)\cdot n_i + t \cdot n_i + r \cdot c_i] ^ 2<br>$$</p>
</blockquote>
<p>这里依据的是向量积的坐标表示。<br><a href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A7%AF" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A7%AF</a><br>wiki中“三维坐标”一节中的说明。</p>
<p><strong>实现参考</strong><br><a href="http://www.cnblogs.com/sddai/p/6129437.html" target="_blank" rel="external">http://www.cnblogs.com/sddai/p/6129437.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ICP迭代最近点方法，是三维建模中将点云模型对齐的一种常用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="ICP, 点云对齐" scheme="http://hengyishu.cn/tags/ICP-%E7%82%B9%E4%BA%91%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>k-d树</title>
    <link href="http://hengyishu.cn/2017/02/16/k-d%E6%A0%91/"/>
    <id>http://hengyishu.cn/2017/02/16/k-d树/</id>
    <published>2017-02-16T08:44:43.000Z</published>
    <updated>2017-03-08T08:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>k-d树是查找相邻点很重要的一种数据结构。<br><a id="more"></a></p>
<blockquote>
<p>索引结构中相似性查询有两种基本的方式：一种是<strong>范围查询</strong>（range searches），另一种是<strong>K近邻查询</strong>（K-neighbor searches）。<br>范围查询就是给定查询点和查询距离的阈值，从数据集中找出所有与查询点距离小于阈值的数据；<br>K近邻查询是给定查询点及正整数K，从数据集中找到距离查询点最近的K个数据，当K=1时，就是最近邻查询（nearest neighbor searches）。</p>
</blockquote>
<p>特征匹配算子可以分为两类，一类是线性扫描法（穷举），一类是建立数据索引，然后进行快速匹配。</p>
<p>k-d树是索引树的一种。划分的空间没有混叠（clipping）的，另一种划分空间是有混叠（overlapping）的。</p>
<p>k-d树的算法分为两类，一类是有关k-d树的构建算法，一类是在k-d树上进行邻近查找的算法。</p>
<h3 id="k-d树的构建算法"><a href="#k-d树的构建算法" class="headerlink" title="k-d树的构建算法"></a>k-d树的构建算法</h3><p>k-d是k-dimension的缩写，是对数据点在k维空间中划分的一种数据结构。k-d树实际上是一种二叉树。<br>它结点内容包括：</p>
<table>
<thead>
<tr>
<th>数据名</th>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>dom_elt</td>
<td>k维的向量</td>
<td>k维空间中的一个点，k-d树在某个维度以这个点为界进行划分</td>
</tr>
<tr>
<td>split</td>
<td>正数</td>
<td>表示进行划分的维数的序号</td>
</tr>
<tr>
<td>left</td>
<td>kd-tree</td>
<td>左子树</td>
</tr>
<tr>
<td>right</td>
<td>kd-tree</td>
<td>右子树</td>
</tr>
</tbody>
</table>
<p>注意split是当前结点进行划分的维数的序号，序号只是为了在算法中表示方便，其实就是维度的标识。</p>
<p><strong>算法描述</strong></p>
<p><strong>split选取</strong><br>选取split时，为了得到较好的划分效果（较高的分辨率），通常做法是，计算每个维度的方差$\sigma_i$，如果$\sigma_p$是$\sigma_i$中最大的，那么取维度$p$作为split。</p>
<p><strong>dom_elt选取</strong><br>将所有元素按照split维的数值大小进行排序，取最中间的那个元素作为dom_elt。</p>
<p><strong>建立子树</strong><br>假设ele为k维空间中的任意，对dom_elt一侧的数据($ele[split]\le dom_elt[split]$)建立左子树，树根为当前结点的左子结点。另一侧的数据($ele[split] &gt; dom_elt[split]$)建立右子树，树根为当前结点的右子节点。</p>
<blockquote>
<p>伪代码<br>算法：构建k-d树(build_kd_tree)<br>输入：k维点集ele_set<br>输出：k-d树 kd_t</p>
<ol>
<li>如果ele_set 为空，则返回空</li>
<li>调用选择分裂点的子程序，得到分裂点dom_elt和分裂的维度split</li>
<li>ele_set_left = $\{e | e \in ele_set, e[split] \le dom_elt[split] \} $<br>ele_set_right = $\{e | e \in ele_set, e[split] \gt dom_ elt[split]\} $</li>
<li>build_kd_tree(ele_set_left)<br>build_kd_tree(ele_set_right)</li>
</ol>
</blockquote>
<p>分裂点指的是结点中的dom_elt值，标识了当前分裂的界线。</p>
<h3 id="k-d树的邻近查找"><a href="#k-d树的邻近查找" class="headerlink" title="k-d树的邻近查找"></a>k-d树的邻近查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">算法：k-d树查找target点的最近邻点(find_kd_tree)</div><div class="line">输入：k-d树kd_tree, 目标点 target</div><div class="line">输出：目标的最近邻点nearest, 最近距离dist</div><div class="line"></div><div class="line"><span class="number">1.</span> 如果kd_tree为空，则设dist为无穷大，返回</div><div class="line"><span class="number">2.</span> 搜索k-d树直到叶子结点，记录搜索过的路径</div><div class="line">pSearch 指向 kd_tree的根节点</div><div class="line"><span class="keyword">while</span>(pSearch指向的结点p不是叶子结点)</div><div class="line">&#123;</div><div class="line">    将p加入到search_path中</div><div class="line">    <span class="keyword">if</span>(target[p.split] &lt;= p.dom_elt[p.split])&#123;</div><div class="line">        pSearch指向当前结点的左子树    </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        pSearch指向当前结点的右子树</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">取出search_path中最后一个赋值给nearest</div><div class="line">dist = Distance(nearest, target)</div><div class="line"><span class="number">3.</span> 回溯搜索路径</div><div class="line"><span class="keyword">while</span>(search_path 不为空)</div><div class="line">&#123;</div><div class="line">    pBack = search_path最后一个元素</div><div class="line">    <span class="keyword">if</span>(pBack 为叶子结点)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(Distance(nearset, target) &gt;</div><div class="line">           Distance(pBack-&gt;dom_elt, target) )</div><div class="line">        &#123;</div><div class="line">            nearset = pBack-&gt;dom_elt</div><div class="line">            dist = Distance(pBack-&gt;dom_elt, target)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        s = pBack-&gt;split</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pBack-&gt;dom_elt[s] - target[s]) &lt; dist)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>( Distance(nearest, target) &gt; </div><div class="line">                Distance(pBack-&gt;dom_elt, target) )  </div><div class="line">            &#123;  </div><div class="line">                nearest = pBack-&gt;dom_elt;  </div><div class="line">                dist = Distance(pBack-&gt;dom_elt, target);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span>(target[s] &lt;= pBack-&gt;dom_elt[s]) </div><div class="line">                pSearch = pBack-&gt;right;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                pSearch = pBack-&gt;left;</div><div class="line">            <span class="keyword">if</span>(pSearch != <span class="literal">NULL</span>)  </div><div class="line">                pSearch加入到search_path中      </div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>参考:</strong><br><a href="http://underthehood.blog.51cto.com/2531780/687160" target="_blank" rel="external">http://underthehood.blog.51cto.com/2531780/687160</a><br><a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank" rel="external">k-d tree wikipedia</a><br><a href="http://www.cnblogs.com/eyeszjwang/articles/2429382.html" target="_blank" rel="external">http://www.cnblogs.com/eyeszjwang/articles/2429382.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k-d树是查找相邻点很重要的一种数据结构。&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="数据结构" scheme="http://hengyishu.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我的二〇一六</title>
    <link href="http://hengyishu.cn/2017/01/31/%E6%88%91%E7%9A%84%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AD/"/>
    <id>http://hengyishu.cn/2017/01/31/我的二〇一六/</id>
    <published>2017-01-31T11:02:03.000Z</published>
    <updated>2017-02-14T03:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>写下这些文字的时候，2017已经过去了将近一个月。好久没有写过东西，以前觉得有些想法就让他烂在心里的好，然而现在觉得生活中零零碎碎的东西如果都烂掉了，岂不是太过可惜，不如记下，偶尔翻看，回味一番。</p>
<a id="more"></a>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>2016元旦，许久不见的小伙伴们大学中最后一次相约在钟楼下跨年，大学四年，对钟楼广场的一草一木熟悉得不得了，小伙伴们虽然许久未见，但是彼此没有任何陌生之感。跨年早已没有最初的兴奋与激动，只是觉得这有可能是最后一次跨年的机会，如果不在，一定会相当可惜。</p>
<p>钟楼广场依旧熙熙攘攘，中间为了看舞台表演，大家分成两拨不幸走散。相约在我们院办楼下集合，但是人实在是太多，走着走着跨年倒计时已经响起，驻足观望，忽然发现身边一个小伙伴都没有，不禁一阵感叹，静静地听完钟声，大家终于会合一处，拍照留念，道别。</p>
<p>一月份的后半个月，就配合材料院的张正武老师一起为学生处做年度总结会上用的年度总结视频，之前跟学生处的人合作过，也知道了他们的工作流程和大概效率，整个过程并不着急，边做边等放假，到一月底年度总结会召开时候总算完工，还记得当时寒假已经放假两天了，终于到家，准备迎接新年。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>这个寒假是本科最后一次寒假，毕设开题已经结束，自己慢慢悠悠地学习毕设中需要用到的东西，偶尔看一下读研需要用到的知识，写写代码。齐老师也没有要求我到北京去，所以一直待到校历开学才不情愿地从家赶到学校。</p>
<p>寒假的红包大战，是微信支付宝第一次也是最后一次红包大战（2017微信没有了，QQ出战了）。我也参与了集福大战，然而并没有好运集到全部的福卡去分得六百多块钱。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>武汉之行计划了半个多月，本来四个小伙伴，最后一个小伙伴因为要去北京面试去不了，只剩我陪两只萌妹子一起开启武汉之旅。本来打算毕业这段时间除了武汉之外再去其他地方，但是因为各种各样的原因就给耽误掉了，不过毕业旅行还算没有耽误。也第一次在旅行的时候花了半天时间上网打游戏。</p>
<p>毕设也如期进行，石磊老师得我们相当和蔼，我们所有同学也在尽自己努力配合老师的工作。开题报告修改，翻译文献等等都稳步推进。</p>
<p>四年里也第一次逛了逛数学楼旁边的海棠大道和樱花林，不得不说，除了那块石头比较蠢之外，花还都是相当漂亮的。</p>
<h2 id="四五"><a href="#四五" class="headerlink" title="四五"></a>四五</h2><p>总觉的毕业还很遥远，但是时光不紧不慢毫不留情。从武汉回来之后，发现自己的毕设进度有点落后，为了赶上中期检查，抓紧时间进行了一番恶补，总算没有落下后腿。然后整个四月底五月都在日夜不停地写代码，虽然我的毕设题目算是比较直接，但是其中还是有很多细节需要一点点地学习和实现。最终，在五月中的时候，代码部分基本完成，不禁松了一口气，开始准备文档，等待答辩的那一天。</p>
<p>五月末的时候，毕业视频的工作又找到了我，还在学校的一伙同学就凑成了一个团队，为了毕业视频的工作紧张筹备。本来对于这个工作我是拒绝的，但是加入之后发现一起工作的小伙伴们务实又有趣，于是决定还是留下来跟大家一起完成为同学们准备的最后一个礼物。虽然大家都没有参与过相关的活动，但是大家热情都很高涨，而且直到跟老师一起合作，才发现王成和杜晨健老师也是相当开明，跟之前的印象有挺大区别。</p>
<h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>六月之前一直觉得毕业季还很遥远，后来才发现是自己不愿意认真地考虑这些事情，有意无意地就回避掉了这个问题。六月正式进入毕业季，答辩、班级合影、毕业典礼，所以这些事情一股脑地冲了进来，没有时间感慨，没有时间挽留，像身处巨大的水流之中，不断地被推着前进，能做的只能是把这些事情留在记忆里，慢慢回味。</p>
<p>答辩远比我想象的简单，把自己准备的材料加速加速再加速一股脑说完，老师简单提问一下，前后不到十分钟，就标志着自己本科的学习生涯真的结束了。答辩结束之后，大家郑重地把自己的论文光盘放进档案袋里，外面写上自己的名字。教室里空调坏了，很热又很吵，所有的小伙伴们却写的很慢很认真。把档案袋收起来交给老师的那一刻，心里仍然有些许遗憾，觉得论文还可以写的更优美，程序设计可以更完善。而且论文交了之后，大部分同学的学生生涯就宣告结束，我也要准备开启新的篇章。无论怎么样，大家都还是恋恋不舍。</p>
<p>班级合影，同班四年，合影这天一定是全班同学感情最真挚热烈的一天。从早到晚，男生西服西裤，女生汉服，顶着大太阳拍了一整天的照片。在教室拍照的时候我还摔了一跤，不过好在照片效果相当不错，我趁机也和全班每个同学拍了张合影，觉得即便是我以后记不得所有人的名字，我也还有这些珍贵的记录。</p>
<p>毕业典礼，三年观众，终成主角。我们将近十个人忙活了一个多月的毕业视频在毕业典礼上给大家送去了大学四年最后的回忆。虽然有诸多的瑕疵，制作过程中也遇到了各种各样的问题，但我们所有小伙伴付出了心血，不管怎么样，我们最后交出了一份还算满意的作品。</p>
<p>毕业季，活宝们也终将分别，我们来自天南海北，有缘能够在郑州相识，更庆幸大家可以在四年之后仍然是好朋友。毕业典礼的前一天，大家最后一次一起到ktv纳凉，在菊园候车亭吃了西瓜聊了聊天，好像不是即将分别，而是像刚认识的时候那种夜宵小聚，没有太多的离别感伤，虽然不知道大家下次再见会是在哪，但是我们彼此都有一定会再见的笃定。看着在篮球场附近拍的照片，想起最初活宝们一起玩耍的小伙伴有好几十个，最后都因为各种各样的原因离开，只剩下照片里这几个不离不弃的小伙伴。祝大家都能各自安好吧。</p>
<h2 id="七八"><a href="#七八" class="headerlink" title="七八"></a>七八</h2><p>闲散的假期，有空就看书看电影动画片听歌写代码。七月底跟妈妈一块去洛阳，见到了最漂亮的蓝天白云。游泳时不注意，半个月的中耳炎也让我夏天的出行计划泡汤。</p>
<p>这个假期跟之前最大的不同就是小伙伴们大都开始了职场生涯，再也不能随时开黑，不能没有限制随意玩耍。我的内心是开心又失落的，开心大家未来都有了着落，逐渐开启了各自新的人生道路，失落是大家以后见面的机会越来越少，也可能会渐行渐远。我只希望无论人在哪，情谊永不褪色。</p>
<h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><p>期待了一年，总算开学，整夜的火车，坐着最早的一班地铁赶到学校。报到、注册、认识师兄同学，一切都带着最初的新鲜与好奇心，看着亚洲最大的NMB、帝都最漂亮的林荫大道、设施完善的实验室和体育馆，心中激动无以言表。接着选课、上课、读论文、读代码，渐渐冷静下来，开始和小伙伴们吐槽学校的点点滴滴：建筑命名无脑粗暴、上课教室搞得人晕头转向、上四层楼等于上八层、下午课跟晚上课之间只有十五分钟吃饭时间、图书馆找书简直不能更麻烦…</p>
<p>研究和课程的任务不断增加，逐渐感到了身上的压力，在一遍遍地赶DDL中，慢慢地适应了读研的节奏，也逐渐掌握了一些论文阅读和研究的方法，自己在研究人员的道路上逐渐地驾轻就熟。</p>
<h2 id="十十一"><a href="#十十一" class="headerlink" title="十十一"></a>十十一</h2><p>读研之后第一个长假，约了小伙伴天津之行。没想到这次旅行让我萌生了重新拾起过去遗憾的想法。认识了四年的姑娘，之前总觉得没有做好准备，也看不太清楚自己的未来，认为不会有什么结果。终于在那个阴雨绵绵的傍晚，我鼓起所有的勇气闯入了她的世界，开始相信无论前路如何，总能风雨同舟携手前行。相处时间越久，我就越感到庆幸自己没有因为犹豫而错过身边这么优秀的姑娘。我们就像相恋多年的恋人一样，彼此那么地默契合拍，彼此尊重和依赖，努力而专心地呵护着对方的感情。</p>
<p>我的人生旅途从此多了一个伴侣，每天电话都有说不完的话，一起记录生活，同步彼此的作息，同步追剧，她的光芒让我整个时光都填满了甜蜜和温柔。而帝都多了一对好奇探路者，我们一起探索这千年古都，一起搜索神秘美食，一起参观帝都的角角落落，在越来越多的地方留下我们的脚印。我们满怀信心，爱着彼此，不畏前路。</p>
<h2 id="十二"><a href="#十二" class="headerlink" title="十二"></a>十二</h2><p>选课太多，DDL几乎都积攒在年底，十二月一直忙忙忙，从来没有停下。先是各个科目的大作业，然后完成一些科目需要提交的论文代码，一路跌跌撞撞地进入期末复习。发现小伙伴们都已经不在意大家彼此的成绩对比，都会一起讨论课程内容，对课程重点内容做出自己的判断，然后各自或者一起做出一份复习总结，大家开始齐心协力进行期末复习，都不希望任何人因为课程的原因而耽误了自己的研究生涯。</p>
<p>最终，紧紧张张的考试总算结束，考试并没有我们担心的那么恐怖，而更像是一个资格审查，进行完这些考核，才标志着我们终有资格进行下一步的研究生活。要感谢一起复习的甲丙丁，大家下个学期也要一起努力，少打撸多看论文多看书！</p>
<h2 id="二〇一七"><a href="#二〇一七" class="headerlink" title="二〇一七"></a>二〇一七</h2><p>两天时间总算把二〇一六年过了一遍，之前也想写过类似的内容，但是最后不了了之，这次总算完成。新年愿望这算是完成的第一个，其他的愿望列在下面：</p>
<ul>
<li>把日记本用满一整年</li>
<li>重新开始更新自己的博客，写什么都行</li>
<li>记录自己读过的书，照片文字都行</li>
<li>接着记录自己看过的电影</li>
<li>在研究之路上有所突破</li>
<li>坚持运动</li>
<li>把github也用起来</li>
</ul>
<p>二〇一七，不忘初心，鸡年大吉！</p>
<p><strong>二〇一七一月二十七 除夕</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零&quot;&gt;&lt;a href=&quot;#零&quot; class=&quot;headerlink&quot; title=&quot;零&quot;&gt;&lt;/a&gt;零&lt;/h2&gt;&lt;p&gt;写下这些文字的时候，2017已经过去了将近一个月。好久没有写过东西，以前觉得有些想法就让他烂在心里的好，然而现在觉得生活中零零碎碎的东西如果都烂掉了，岂不是太过可惜，不如记下，偶尔翻看，回味一番。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hengyishu.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="2016" scheme="http://hengyishu.cn/tags/2016/"/>
    
      <category term="总结" scheme="http://hengyishu.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[Qt]OpenGL与Qt结合|OpenGL under QML</title>
    <link href="http://hengyishu.cn/2016/03/22/Qt-OpenGL%E4%B8%8EQt%E7%BB%93%E5%90%88-OpenGL-under-QML/"/>
    <id>http://hengyishu.cn/2016/03/22/Qt-OpenGL与Qt结合-OpenGL-under-QML/</id>
    <published>2016-03-22T06:24:50.000Z</published>
    <updated>2017-02-14T03:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>写个demo感受一下OpenGL如何在Qt上应用。<br><a id="more"></a></p>
<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><blockquote>
<p>开放图形库（英语：Open Graphics Library，缩写为OpenGL）是个定义了一个跨编程语言、跨平台的应用程序接口（API）的规范，它用于生成二维、三维图像。这个接口由近350个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟实境、科学可视化程序和电子游戏开发。</p>
<p>OpenGL的高效实现（利用了图形加速硬件）存在于Windows，很多UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。开放源代码库Mesa是一个纯基于软件的图形API，它的代码兼容于OpenGL。但是，由于许可证的原因，它只声称是一个“非常相似”的API。<br>-摘自<a href="https://zh.wikipedia.org/wiki/OpenGL" title="OpenGL wiki" target="_blank" rel="external">OpenGL wiki</a></p>
</blockquote>
<p>关于OpenGL的编程展开是个很大的话题，不再赘述，有兴趣的可以参考</p>
<ul>
<li><a href="http://www.learnopengl.com/" title="learnopengl" target="_blank" rel="external">LearnOpenGL</a></li>
<li><a href="http://www.opengl-tutorial.org/" title="opengltutorail" target="_blank" rel="external">OpenGLTutorial</a></li>
</ul>
<h1 id="OpenGL与Qt结合"><a href="#OpenGL与Qt结合" class="headerlink" title="OpenGL与Qt结合"></a>OpenGL与Qt结合</h1><p>我写的demo参考这篇文章：<a href="http://doc.qt.io/qt-5/qtquick-scenegraph-openglunderqml-example.html" title="openglunderqml" target="_blank" rel="external">OpenGLUnderQML</a><br>因为之前写文本编辑器的原因，现在看这篇教程感觉容易理解的多。跟着写就好，主要就是理解一下Qt中究竟是如何将OpenGL结合起来的。</p>
<p>这个demo简明扼要，主要思路如下：</p>
<ol>
<li>写Squircle类和Squirecle类，前者作为组件注册进qml，后者作为Squircle类中的一个成员，处理一些渲染的问题。定义一些信号函数和一些槽函数。</li>
<li>在qml中写好布局</li>
<li>在qml中修改Squircle中的成员t的值</li>
<li>每次渲染都会根据t的值进行，从而画出不同的图案</li>
</ol>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>The OpenGL under QML example shows how an application can make use of the QQuickWindow::beforeRendering() signal to draw custom OpenGL content under a Qt Quick scene. This signal is emitted at the start of every frame, before the scene graph starts its rendering, thus any OpenGL draw calls that are made as a response to this signal, will stack under the Qt Quick items.</p>
<p>As an alternative, applications that wish to render OpenGL content on top of the Qt Quick scene, can do so by connecting to the QQuickWindow::afterRendering() signal.</p>
<p>本例展示了应用程序如何利用<code>QQuickWindow::beforeRendering</code>信号在QtQuick场景下画出自定义的OpenGl内容。这个信号会在每一帧渲染之前触发，也就是在图像场景绘制之前，因此任何此信号的槽函数中的OpenGL调用都会栈式堆叠在QtQuick控件之下。<br>另外，如果应用程序想要在QtQuick控件之上绘制图像，那么可以针对<code>QQuickWindow::afterRendering</code>信号编写槽函数并与之连接。 </p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="用到的信号"><a href="#用到的信号" class="headerlink" title="用到的信号"></a>用到的信号</h2><h3 id="QQuickItem-windowChanged"><a href="#QQuickItem-windowChanged" class="headerlink" title="QQuickItem::windowChanged"></a>QQuickItem::windowChanged</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Squircle::Squircle()</div><div class="line">    : <span class="keyword">m_t</span>(<span class="number">0</span>)</div><div class="line">    , m_renderer(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    connect(<span class="keyword">this</span>, &amp;QQuickItem::windowChanged, <span class="keyword">this</span>, &amp;Squircle::handleWindowChanged);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>void QQuickItem::windowChanged(QQuickWindow *window)<br>This signal is emitted when the item’s window changes.</p>
</blockquote>
<h3 id="void-QQuickWindow-beforeSynchronizing"><a href="#void-QQuickWindow-beforeSynchronizing" class="headerlink" title="void QQuickWindow::beforeSynchronizing()"></a>void QQuickWindow::beforeSynchronizing()</h3><blockquote>
<p>This signal is emitted before the scene graph is synchronized with the QML state.<br>This signal can be used to do any preparation required before calls to QQuickItem::updatePaintNode().<br>The GL context used for rendering the scene graph will be bound at this point.<br>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).<br>Warning: Make very sure that a signal handler for beforeSynchronizing leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</blockquote>
<p>同步的信号</p>
<h3 id="void-QQuickWindow-sceneGraphInvalidated"><a href="#void-QQuickWindow-sceneGraphInvalidated" class="headerlink" title="void QQuickWindow::sceneGraphInvalidated()"></a>void QQuickWindow::sceneGraphInvalidated()</h3><blockquote>
<p>This signal is emitted when the scene graph has been invalidated.<br>This signal implies that the opengl rendering context used has been invalidated and all user resources tied to that context should be released.<br>The OpenGL context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt’s control, for instance through EGL_CONTEXT_LOST.<br>This signal will be emitted from the scene graph rendering thread.</p>
</blockquote>
<p>场景渲染结束，需要释放资源的信号</p>
<h3 id="void-QQuickWindow-beforeRendering"><a href="#void-QQuickWindow-beforeRendering" class="headerlink" title="void QQuickWindow::beforeRendering()"></a>void QQuickWindow::beforeRendering()</h3><blockquote>
<p>This signal is emitted before the scene starts rendering.</p>
<p>Combined with the modes for clearing the background, this option can be used to paint using raw GL under QML content.</p>
<p>The GL context used for rendering the scene graph will be bound at this point.</p>
<p>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</p>
<p>Warning: Make very sure that a signal handler for beforeRendering leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</blockquote>
<p>前面介绍过的图形渲染之前的信号</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="文件名的写法"><a href="#文件名的写法" class="headerlink" title="文件名的写法"></a>文件名的写法</h3><p>QOpenGLShaderProgram的方法addShaderFromFile中的第二个参数需要一个文件名，这个文件名我最开始写的是<code>&quot;vertex.vsh&quot;</code>，结果一直提示找不到文件，查了查，看到别人代码写成<code>&quot;:/vertex.vsh&quot;</code>就可以了。不太清楚是为什么。</p>
<h3 id="关于Qt-main函数中的窗口启动方式"><a href="#关于Qt-main函数中的窗口启动方式" class="headerlink" title="关于Qt main函数中的窗口启动方式"></a>关于Qt main函数中的窗口启动方式</h3><ol>
<li>现在见到的有几种，通过ApplicationEngine读取qml，在qml中定义window，然后出现窗口</li>
<li>QQuickView直接载入qml文件，然后显示出来</li>
</ol>
<p>-END-</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写个demo感受一下OpenGL如何在Qt上应用。&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="学习记录" scheme="http://hengyishu.cn/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Qt" scheme="http://hengyishu.cn/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>[Qt]使用C++编写QML组件</title>
    <link href="http://hengyishu.cn/2016/03/18/Qt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8C-%E7%BC%96%E5%86%99QML%E7%BB%84%E4%BB%B6/"/>
    <id>http://hengyishu.cn/2016/03/18/Qt学习记录-使用C-编写QML组件/</id>
    <published>2016-03-18T13:58:00.000Z</published>
    <updated>2017-02-14T03:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>初学Qt，官网文档看的有点乱乱的，经常找不到自己需要的东西。于是决定跟着官网的一篇文章写一个Demo–一个简单的文本编辑器，参考教程在<a href="http://doc.qt.io/qt-5/gettingstartedqml.html" title="Getting Started Programming with Qt Quick" target="_blank" rel="external">这里</a><br><a id="more"></a></p>
<h1 id="QML-amp-QML-modules"><a href="#QML-amp-QML-modules" class="headerlink" title="QML &amp; QML modules"></a>QML &amp; QML modules</h1><p>QML (Qt Markup Language<a href="https://zh.wikipedia.org/wiki/QML" title="QML wikipedia" target="_blank" rel="external">2</a> 或 Qt Meta Language 或 Qt Modeling Language<a href="http://doc.qt.io/qt-5/gettingstartedqml.html" title="Getting Started Programming with Qt Quick" target="_blank" rel="external">3</a>) 是基于JavaScript、宣告式编程的编程语言，用于设计用户界面为主的应用程序。它是Qt Quick，诺基亚开发的用户界面创建包的一部分。QML 主要用于移动应用程序，注重于触控输入、流畅的动画（60张/秒）和用户体验。QML documents 描述元素的对象树。</p>
<p>QML 元素可以通过标准 JavaScript 增强，包括这 inline 和引入.js 档。元素可以也无缝集成和使用 Qt 框架的 C++ 组件扩展。</p>
<p>语言的名称是 QML。runtime的名称是 QQuickView。</p>
<p>===以上来自<a href="https://zh.wikipedia.org/wiki/QML" title="QML wikipedia" target="_blank" rel="external">QML wiki</a>===</p>
<p>简而言之，QML是一个基于javascript的语言，能够方便地进行用户界面设计，也能够通过引入js文件和访问c++对象来拓展功能，使用方便又功能强大。</p>
<p>QML官方参考文档: <a href="http://doc.qt.io/qt-5/qtqml-index.html" title="Qt QML" target="_blank" rel="external">QtQML</a></p>
<h1 id="QML访问C-对象"><a href="#QML访问C-对象" class="headerlink" title="QML访问C++对象"></a>QML访问C++对象</h1><p>使用Qt的重点就在于如何将QML与自己需要实现的功能代码相结合，既满足QML简单的特点，又能实现自己所需要的功能。<br>开头就提到，我是跟着这篇教程–<a href="http://doc.qt.io/qt-5/gettingstartedqml.html" title="Getting Started Programming with Qt Quick" target="_blank" rel="external">Getting Started Programming with Qt Quick</a>做的Demo，想要先熟悉一下开发过程。<br>接下来就是入坑爬坑的阶段了。</p>
<p>环境说明： </p>
<ul>
<li>win10</li>
<li>Qt5.5 for msvs2013 64bit</li>
<li>QtCreator</li>
</ul>
<p><strong>教程内的源码包含在Qt的Example文件夹内！地址类似这样 Qt\Qt5.5.1\Examples\Qt-5.5\quick\tutorials\gettingStartedQml</strong></p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>想了解Qt Quick 1 vs Qt Quick 2的同学请移步: <a href="https://wiki.qt.io/QML1-vs-QML2" title="QML1-vs-QML2" target="_blank" rel="external">QML1-vs-QML2</a><br>这个过程教程里没有详细说明，因为使用的控件都是自己写的，所以新建一个Qt Quick的工程就好。</p>
<h2 id="写qml控件"><a href="#写qml控件" class="headerlink" title="写qml控件"></a>写qml控件</h2><p>跟着教程写控件包括 Button, EditMenu, FileMenu，MenuBar这些东西，参考源码的内容写就好，这时候因为有些交互代码（比如点击按钮要进行保存之类的）没有相应的C++代码支持，所以会报错，这些报错的内容可以先不写，后面再补上。</p>
<h2 id="写C-对象"><a href="#写C-对象" class="headerlink" title="写C++对象"></a>写C++对象</h2><p>也是参考源码来写，没什么大问题，这个地方不会有什么报错的，就跟着Qt的教程把需要的写的宏和语句写好了就行</p>
<h3 id="重要的宏"><a href="#重要的宏" class="headerlink" title="重要的宏"></a>重要的宏</h3><p>重要的宏有这几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//类定义的时候需要</div><div class="line">Q_OBJECT</div><div class="line"></div><div class="line">//设定属性已经读写属性对应的C++函数以及发出的那种信号</div><div class="line">Q_PROPERTY(type propertyName READ propertyName Write setPropertyName NOTIFY signalName)</div><div class="line"></div><div class="line">//可以被QML调用的函数</div><div class="line">Q_INVOKABLE void yourFunctionName( args.. );</div></pre></td></tr></table></figure></p>
<p>为什么要用这些宏，参考官方文档：<br><a href="http://doc.qt.io/qt-5/qobject.html#Q_OBJECT" title="Q_OBJECT" target="_blank" rel="external">Q_OBJECT</a><br><a href="http://doc.qt.io/qt-5/qobject.html#Q_PROPERTY" title="Q_PROPERTY" target="_blank" rel="external">Q_PROPERTY</a><br><a href="http://doc.qt.io/qt-5/qobject.html#Q_INVOKABLE" title="Q_INVOKABLE" target="_blank" rel="external">Q_INVOKABLE</a><br>更多宏，请参考<a href="http://doc.qt.io/qt-5/qobject.html" title="QObject" target="_blank" rel="external">QObject</a>的Macros小节</p>
<h2 id="QML访问C-对象-1"><a href="#QML访问C-对象-1" class="headerlink" title="QML访问C++对象"></a>QML访问C++对象</h2><p>这是个难点，把QML的样式写好之后，需要添加功能，相应的C++代码也写好了，但是要结合起来还是有点麻烦。<br>上面提到的教程是通过qmlscene带参运行，来达到qml和C++代码的结合，但是这样的话就不能在Qt Creator中写代码时，看到提示了，很难受，所以就得看看其他的办法。</p>
<h3 id="Qt-Creator-中使用qmlscene运行项目"><a href="#Qt-Creator-中使用qmlscene运行项目" class="headerlink" title="Qt Creator 中使用qmlscene运行项目"></a>Qt Creator 中使用qmlscene运行项目</h3><p>顺带说一下如何在Qt Creator中使用qmlscene运行demo中的源码</p>
<ol>
<li>使用qmake生成imports文件夹，生成文件夹的地址得在 <code>QtCreator -》 项目</code> 中构建设置下的shadow build是否打钩，如果打钩，那么生成的文件会在 构建目录中。没有打钩的话，就是在项目文件夹下生成。</li>
<li>把imports放到demo源码的目录</li>
<li>配置运行参数<br>在 QtCreator -》项目 中的设置如图<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/qt-qml-qmlscene.png" alt="qtCreator-qmlscene"><br>参数也如图中所示，接下来运行即可</li>
<li>注意：第一步中生成imports的文件夹要和第3步中的运行时的版本是一致的，也就是说如果生成imports时是release版，那么第3部构建时也需要是release，如果是debug版的就都需要时debug版，不能混用。</li>
</ol>
<h3 id="不使用qmlscene运行"><a href="#不使用qmlscene运行" class="headerlink" title="不使用qmlscene运行"></a>不使用qmlscene运行</h3><p>qt自带的源码中的项目打开，目录结构是这样的<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/qt-qml-getstartedqml.png" alt="目录结构"><br>可以看到，没有qml相关的文件<br>我也不太明白为什么要这样设置，但是使用上面提到的qmlscene的方法确实可以运行。<br>然后我就想了想办法，把c++代码和qml结合起来。</p>
<p>在我们自己建的项目中，把写好的c++代码的头文件和源代码文件添加进项目，然后在main函数QmlApplicationEngine初始化之前把我们自己写的FileDialog组件注册一下就好，代码如下(添加的就是星号之间的代码)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGuiApplication&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QQmlApplicationEngine&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"FileDialog/dialogPlugin.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</div><div class="line">	</div><div class="line"><span class="comment">//****************************</span></div><div class="line">    DialogPlugin plugin;</div><div class="line">    plugin.registerTypes(<span class="string">"FileDialog"</span>);</div><div class="line"><span class="comment">//****************************</span></div><div class="line"></div><div class="line">    QQmlApplicationEngine engine;</div><div class="line">    engine.load(QUrl(QStringLiteral(<span class="string">"qrc:/main.qml"</span>)));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> app.exec();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>项目结构如下<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/qt-qml-motepad.png" alt="motepad"></p>
<p>然后再进行构建，运行就可以运行了。</p>
<p>而且，这样写的话，在qml文件中import FileDialog之后，可以看到自己定义的那些属性和可以被引用的方法！</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="必要的qt头文件没有include"><a href="#必要的qt头文件没有include" class="headerlink" title="必要的qt头文件没有include"></a>必要的qt头文件没有include</h3><p>必要的qt头文件没有include，导致构建时出现了莫名其妙的错误，看log也看不出来代码哪里写错了，全是stdio.h中的错误。以后要谨记这点。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="http://doc.qt.io/qt-5/qtqml-tutorials-extending-qml-example.html" title="Writing QML Extensions with C++" target="_blank" rel="external">Writing QML Extensions with C++</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学Qt，官网文档看的有点乱乱的，经常找不到自己需要的东西。于是决定跟着官网的一篇文章写一个Demo–一个简单的文本编辑器，参考教程在&lt;a href=&quot;http://doc.qt.io/qt-5/gettingstartedqml.html&quot; title=&quot;Getting Started Programming with Qt Quick&quot;&gt;这里&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="学习记录" scheme="http://hengyishu.cn/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Qt" scheme="http://hengyishu.cn/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt5.5 + Visual Studio 2013 结合</title>
    <link href="http://hengyishu.cn/2016/03/12/Qt5-5-Visual-Studio2013-%E7%BB%93%E5%90%88/"/>
    <id>http://hengyishu.cn/2016/03/12/Qt5-5-Visual-Studio2013-结合/</id>
    <published>2016-03-12T06:50:18.000Z</published>
    <updated>2017-02-14T03:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Qt Creater 编写代码不够舒服，而vs拥有强大的开发调试环境，在vs上进行qt开发，两全其美。<br><a id="more"></a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>本文适用情况仅限于windows环境下，其他环境不保证具有参考意义。</li>
</ul>
<h1 id="VisualStudio"><a href="#VisualStudio" class="headerlink" title="VisualStudio"></a>VisualStudio</h1><p>VisualStudio不多介绍，用过的都说好。<br>到<a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="Download MS VisualStudio" target="_blank" rel="external">VS下载页</a>下载vs2013，安装即可，破解什么的网上有好多，实在不会的话就某宝买一个。</p>
<h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h1><p>Qt - 一套代码，创建强大的应用和设备<br>具体介绍参见<a href="http://www.qt.io/cn/" title="qt Chinese" target="_blank" rel="external">Qt官网</a><br>到目前为止（2016年3月），最新版本的Qt是5.5。<br>安装Qt相当简单，到<a href="http://www.qt.io/cn/download-open-source/" title="Qt Download CN" target="_blank" rel="external">下载页面</a>下载好Qt5.5，安装即可。我用的是Qt 5.5.1 for Windows 64-bit (VS 2013, 823 MB)，然后安装就好了。</p>
<h1 id="在vs2013上使用qt"><a href="#在vs2013上使用qt" class="headerlink" title="在vs2013上使用qt"></a>在vs2013上使用qt</h1><p>在<a href="http://www.qt.io/cn/download-open-source/" title="Qt Download CN" target="_blank" rel="external">Qt下载页</a>中选择Other Downloads,下载<strong>qt-vs-addin-1.2.4-opensource</strong>，或者到<a href="http://download.qt.io/official_releases/vsaddin/qt-vs-addin-1.2.4-opensource.exe.mirrorlist" title="qt vs-add-in 1.2.4" target="_blank" rel="external">这里</a>选择一个网速好点的镜像。<br><strong>qt-vs-addin-1.2.5需要将vs2013升级到最新版，否则安装时候会出现问题。</strong></p>
<p>安装完 qt-vs-addin 之后，在vs的菜单栏上会多出一个菜单选项-qt5，然后，做一下配置。</p>
<ol>
<li>如图配置qt的路径<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/qt-vs-qt-options.png" alt="配置Qt路径"><br><img src="http://7xrsid.com1.z0.glb.clouddn.com/qt-vs-add-path.png" alt="填写路径"><br>这里我的路径是 %你的Qt路径%/Qt/Qt5.5.1/5.5/msvc2013_64 ，然后就配置完毕了。</li>
</ol>
<h2 id="Visual-Assists-x"><a href="#Visual-Assists-x" class="headerlink" title="Visual Assists x"></a>Visual Assists x</h2><p>配置到这里，其实qt已经配置完毕了，但是相信你会看到你编辑器还是会对你的代码报错，毕竟vs再强大，也不可能把所有语法的提示都给你提前做好，所以这时候就需要我们自己安装插件了。<br>这里我选择的是 Visual Assists X，官网在这里:<a href="http://www.wholetomato.com/" title="Visual Assist x - VAX" target="_blank" rel="external">Visual Assists X</a>，下载完，安装就好，然后进行一下简单的配置。参考<a href="http://blog.csdn.net/gameloft9/article/details/46403525" title="vsx 配置" target="_blank" rel="external">这里</a>。<br>然后就可以舒服地写代码了</p>
<p>-END-</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Qt Creater 编写代码不够舒服，而vs拥有强大的开发调试环境，在vs上进行qt开发，两全其美。&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://hengyishu.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="VisualStudio" scheme="http://hengyishu.cn/tags/VisualStudio/"/>
    
      <category term="学习记录" scheme="http://hengyishu.cn/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Qt" scheme="http://hengyishu.cn/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages + Hexo 搭建博客记录</title>
    <link href="http://hengyishu.cn/2016/03/09/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <id>http://hengyishu.cn/2016/03/09/GitHub-Pages-Hexo-搭建博客记录/</id>
    <published>2016-03-09T08:12:01.000Z</published>
    <updated>2017-02-18T02:57:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾经想用阿里云ecs自己搭一个博客，平常可以写点东西放上去，结果过于麻烦并且不必要。Github Pages + Hexo是在windows上很友好的一个组合。<br><a id="more"></a><br>好多教程里用的是 jekyll 来生成静态网页，但是在windows上使用并不是官方推荐的，所以我使用了hexo作为生成工具。</p>
<h1 id="需要安装的软件"><a href="#需要安装的软件" class="headerlink" title="需要安装的软件"></a>需要安装的软件</h1><ul>
<li><a href="https://nodejs.org/en/" title="node.js" target="_blank" rel="external">node.js</a></li>
<li><a href="https://git-scm.com/downloads" title="Git Download Page" target="_blank" rel="external">git</a></li>
<li><a href="https://hexo.io/zh-cn/%20hexo-%E5%BF%AB%E9%80%9F%E3%80%81%E7%AE%80%E6%B4%81%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6" target="_blank" rel="external">hexo</a></li>
</ul>
<h1 id="关于Git及GitHub"><a href="#关于Git及GitHub" class="headerlink" title="关于Git及GitHub"></a>关于Git及GitHub</h1><h2 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h2><p>关于Git的教程网上很多，我推荐我看过的一个<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="廖雪峰的Git教程" target="_blank" rel="external">廖雪峰的Git教程</a><br>里面说的很详细，不再赘述</p>
<h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>GitHub是一个在线托管仓库，GitHub Pages就是把你的仓库变成一个可以访问的静态网站的功能。</p>
<p>相关介绍(同时也是官方教程):<br><a href="https://pages.github.com/" title="GitHub Pages 官方网站" target="_blank" rel="external">GitHub Pages</a></p>
<p>通过Github Pages你可以为你的Github账户建立一个自己的主页，每一个托管在github上的项目都可以作为一个二级目录来展示你网站的相应的部分或者实现相应的功能。</p>
<p>由于只支持静态网页的访问（毕竟免费），所以如果想要搭建博客，那么就需要一套自动生成静态网页的工具，还要整合一些网络上的服务，以便于让自己的博客功能更加丰富。</p>
<h2 id="开启Github-Pages"><a href="#开启Github-Pages" class="headerlink" title="开启Github Pages"></a>开启Github Pages</h2><p>网上各种教程，比如这个:<br><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" title="loveNight hexo3.3.1搭建博客指南" target="_blank" rel="external">Hexo3.3.1搭建博客指南</a></p>
<h1 id="关于Hexo"><a href="#关于Hexo" class="headerlink" title="关于Hexo"></a>关于Hexo</h1><p>官网链接：<br><a href="https://hexo.io/zh-cn/%20hexo-%E5%BF%AB%E9%80%9F%E3%80%81%E7%AE%80%E6%B4%81%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6" target="_blank" rel="external">Hexo - 快速、简洁且高效的博客框架</a><br>需要注意的是安装之前需要先安装node.js，下载请到这里:<br><a href="https://nodejs.org/en/" title="node.js" target="_blank" rel="external">nodejs.org</a><br>hexo安装完成之后，参考hexo官网的文档，或者上面那篇<a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" title="loveNight hexo3.3.1搭建博客指南" target="_blank" rel="external">博客</a>内的说明，就可以使用hexo进行博客的更新的管理了。<br>如果需要美化的话，hexo中提供的有主题，也可以自己根据需要制作。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="git-filename-filepath-too-long"><a href="#git-filename-filepath-too-long" class="headerlink" title="git filename/filepath too long"></a>git filename/filepath too long</h2><p>因为想要保存hexo源文件到github，便于换电脑时候也能写博客（参考<a href="http://zhihu.com/question/21193762/answer/79109280?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" title="CrazyMilk的回答" target="_blank" rel="external">这里</a>），使用<code>git add .</code> 命令时提示node_modules中的文件有一部分因为名字太长而无法访问，找到一个说法是可以在git内设置变量如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.longpaths true</div></pre></td></tr></table></figure></p>
<p>可以让git接收过长的路径名，结果还是不行<br>google了一下发现是windows api的锅，所以只好把 node_modules文件夹放入 .gitignore文件，解决</p>
<h2 id="git-permission-denied"><a href="#git-permission-denied" class="headerlink" title="git permission denied"></a>git permission denied</h2><p>因为 git bash（安装git之后的终端窗口）连接github仓库时需要rsa密钥，我之前用的是github的bash，所以有密钥，就不要生成新的秘钥，再添加到github的白名单里了。<br>添加秘钥的方法参考:<br><a href="https://help.github.com/articles/generating-an-ssh-key/" title="Generating an SSH key" target="_blank" rel="external">Generate a SSH key</a><br><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent" title="Add your SSH key to your ssh-agent" target="_blank" rel="external">Adding your SSH key to the ssh-agent</a></p>
<h2 id="自动替换crlf为lf"><a href="#自动替换crlf为lf" class="headerlink" title="自动替换crlf为lf"></a>自动替换crlf为lf</h2><p>lf是linux系统中使用的换行符，crlf是windows中使用的换行符。<br>因为windows和linux在换行符上的差异。因为跨平台的特性，git默认会检查换行符，并给出警告。<br>一下引用自git官方文档:</p>
<blockquote>
<p><code>core.autocrlf</code><br>假如你正在Windows上写程序，又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。这是因为Windows使用回车和换行两个字符来结束一行，而Mac和Linux只使用换行一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。</p>
<p>Git可以在你提交时自动地把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能，如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF：</p>
<p><code>$git config --global core.autocrlf true</code><br>Linux或Mac系统使用LF作为行结束符，因此你不想<br>Git<br>在签出文件时进行自动的转换；当一个以CRLF为行结束符的文件不小心被引入时你肯定想进行修正，把core.autocrlf设置成input来告诉<br>Git 在提交时把CRLF转换成LF，签出时不转换：</p>
<p><code>$ git config --global core.autocrlf input</code></p>
<p>这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。</p>
<p>如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中：</p>
<p><code>$ git config --global core.autocrlf false</code></p>
</blockquote>
<h2 id="个性化博客"><a href="#个性化博客" class="headerlink" title="个性化博客"></a>个性化博客</h2><p>我使用的是<a href="http://theme-next.iissnan.com/" title="NexT文档" target="_blank" rel="external">NexT-Muse</a>主题，这个主题提供的插件什么的都挺齐全。</p>
<h3 id="为博客添加多说的评论功能"><a href="#为博客添加多说的评论功能" class="headerlink" title="为博客添加多说的评论功能"></a>为博客添加<a href="http://duoshuo.com/" title="多说" target="_blank" rel="external">多说</a>的评论功能</h3><p>配置相当简单，在主题 themes/next/_config.yml 文件中找到如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">duoshuo_info:</div><div class="line">  ua_enable: true</div><div class="line">  admin_enable: true</div><div class="line">  user_id: </div><div class="line">  #admin_nickname: ROOT</div></pre></td></tr></table></figure></p>
<p>user_id 改为自己多说的id<br>ua_enable 是开启获取用户平台功能，开启之后会显示用户所用的操作系统和浏览器版本<br>admin_enable 是开启标记博主功能</p>
<h4 id="获取user-id的方法"><a href="#获取user-id的方法" class="headerlink" title="获取user_id的方法"></a>获取user_id的方法</h4><p>找到自己的留言，在用户名上右键-&gt;检查（资源审查），然后如图<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/bloguser_id.png" alt="获取user_id" title="获取user_id"><br>将拿到的user_id放到，上面那段代码的user_id: 后面，注意<strong>冒号之后</strong>一定要有<strong>空格</strong><br>然后评论后面就会有相应的标记了</p>
<h4 id="多说后台添加自定义css"><a href="#多说后台添加自定义css" class="headerlink" title="多说后台添加自定义css"></a>多说后台添加自定义css</h4><p>一张图说明一切<br><img src="http://7xrsid.com1.z0.glb.clouddn.com/blogcustom_css.png" alt="添加自定义css" title="添加自定义css"></p>
<h3 id="添加统计功能"><a href="#添加统计功能" class="headerlink" title="添加统计功能"></a>添加统计功能</h3><p>使用<a href="http://ibruce.info/2015/04/04/busuanzi/" title="不蒜子简易计数" target="_blank" rel="external">不蒜子</a>，功能介绍详细，使用方便</p>
<h3 id="–2016-3-12更新–"><a href="#–2016-3-12更新–" class="headerlink" title="–2016-3-12更新–"></a>–2016-3-12更新–</h3><h3 id="添加-RSS-订阅"><a href="#添加-RSS-订阅" class="headerlink" title="添加 RSS 订阅"></a>添加 RSS 订阅</h3><p>使用hexo的插件 hexo-generator-feed<br>项目地址: <a href="https://github.com/hexojs/hexo-generator-feed" title="hexo-feed" target="_blank" rel="external">hexo-generator-feed</a><br>安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure></p>
<p>然后在 hexo/_config.yml 中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plugin:</div><div class="line">- hexo-generator-feed</div><div class="line">type: atom</div><div class="line">path: atom.xml</div><div class="line">limit: 20</div></pre></td></tr></table></figure></p>
<p>注意冒号后的空格</p>
<p>然后，再使用 <code>hexo g</code> 命令，就能生成rss文件了</p>
<p>在NexT主题的 _config.xml 中，在rss后面添加 /atom.xml，就会在头像下方出现RSS图标，点击就是刚刚生成的xml文件 </p>
<h3 id="添加-自动生成-sitemap-网站地图"><a href="#添加-自动生成-sitemap-网站地图" class="headerlink" title="添加 自动生成 sitemap(网站地图)"></a>添加 自动生成 sitemap(网站地图)</h3><p>使用 hexo 的插件 hexo-generator-sitemap<br>项目地址：Github:<a href="https://github.com/hexojs/hexo-generator-sitemap" title="hexo-sitemap" target="_blank" rel="external">hexo-generator-sitemap</a><br>安装方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div></pre></td></tr></table></figure></p>
<p>在 hexo/_config.xml 中添加一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sitemap: sitemap.xml</div></pre></td></tr></table></figure></p>
<p>然后再执行 <code>hexo g</code> 之后，访问 yoururl/sitemap.xml 就能看到生成的sitemap文件了。<br>然后把sitemap文件url添加到<a href="http://zhanzhang.baidu.com" title="百度站长" target="_blank" rel="external">百度站长</a>或者<a href="https://analytics.google.com/analytics/web/" title="Google Analytics" target="_blank" rel="external">Google Analytics</a>上，就能够被搜索引擎收录了。</p>
<h2 id="消除hexo转义符对mathjax公式的影响"><a href="#消除hexo转义符对mathjax公式的影响" class="headerlink" title="消除hexo转义符对mathjax公式的影响"></a>消除hexo转义符对mathjax公式的影响</h2><p>参考问题中修改marked.js的回答，目前还没有发现什么问题。<br><a href="https://segmentfault.com/q/1010000003987383/a-1020000003987577" target="_blank" rel="external">https://segmentfault.com/q/1010000003987383/a-1020000003987577</a></p>
<h2 id="github和coding-net-原gitcafe-同时部署"><a href="#github和coding-net-原gitcafe-同时部署" class="headerlink" title="github和coding.net(原gitcafe)同时部署"></a>github和coding.net(原gitcafe)同时部署</h2><p>github的pages服务用百度没办法检索到，只好双备份，github和gitcafe都有。<br>在coding.net上使用pages服务跟github上类似。<br><strong>需要绑定域名时，一定要先在运营商那边添加CNAME条目再在coding.net上绑定相应的域名，否则会不起作用（绑定的时候coding.net也会提醒）</strong><br>想要同时部署，在hexo的blog配置文件中deploy部分改成如下片段就好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deploy: </div><div class="line">- type: git</div><div class="line">  repo: git@github.com:hys2015/blog.git</div><div class="line">  branch: gh-pages</div><div class="line">- type: git</div><div class="line">  repo: git@git.coding.net:markheng/blog.git</div><div class="line">  branch: coding-pages</div></pre></td></tr></table></figure></p>
<p><strong>需要注意branch要对应到pages服务需要的分支才有用。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经想用阿里云ecs自己搭一个博客，平常可以写点东西放上去，结果过于麻烦并且不必要。Github Pages + Hexo是在windows上很友好的一个组合。&lt;br&gt;
    
    </summary>
    
      <category term="日常" scheme="http://hengyishu.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Hexo" scheme="http://hengyishu.cn/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="http://hengyishu.cn/tags/GitHub-Pages/"/>
    
  </entry>
  
</feed>
